DOM (Document Object Model).
Объектная Модель Документа (DOM) – это программный интерфейс (API) для HTML и XML документов. DOM предоставляет структурированное представление документа и определяет то, как эта структура может быть доступна из программ, которые могут изменять содержимое, стиль и структуру документа. Представление DOM состоит из структурированной группы узлов и объектов, которые имеют свойства и методы.
\/+\/+\/+\/+\/+\/+\/
React.js
REACT:
!React — это библиотека JavaScript с открытым кодом для создания внешних пользовательских интерфейсов. В отличие от других библиотек JavaScript, предоставляющих полноценную платформу приложений, React ориентируется исключительно на создание представлений приложений через инкапсулированные единицы (называются компонентами), которые сохраняют состояние и генерируют элементы пользовательского интерфейса.

Все основные концепции React.js
	1. React, библиотека javascript:
React.js — это новаторский инструмент javascript. Это библиотека Javascript на основе интерактивного пользовательского интерфейса, которая популярна благодаря своей способности быстро создавать веб-приложения и мобильные приложения.
Идентификатор React.js создан на платформе с открытым исходным кодом и библиотеке компонентов. Структура MVU (Mobile View Update) определяет окончательный внешний вид вашего приложения.
	2. Согласование дерева React:
Согласование — это процесс обновления реагирующего DOM. Когда состояние изменяется, реакция вычисляет, следует ли обновлять DOM или нет. Виртуальный дом реакции облегчает этот процесс. React.js сравнивает текущий DOM с виртуальным DOM, если состояние изменилось. Этот процесс
Завершено путем diff различные элементы.
	3. ReactDOM.render:
Обычно, когда мы разрабатываем одностраничное приложение, мы вызываем метод рендеринга, и инициализация реагирующего приложения завершается. Метод рендеринга называется основным шлюзом между React и DOM. Метод ReactDOM.render принимает три параметра:
    --Реагировать на элементы
    --Выбранный узел DOM
    --Функция обратного вызова (опционально)
	4. React.createElement:
Метод createElement возвращает новый элемент React определенного типа, указанного в качестве аргумента. Это может быть «div» или «span» и т. д. Код, написанный с помощью JSX, будет преобразован для использования метода createElement.
	5. Вложение элементов React
В React у нас есть возможность создать одностраничное приложение с одним компонентом. Но это не очень хорошая практика. Создание реактивного приложения с несколькими компонентами, разбивающими основной компонент, помогает нам поддерживать качество кода. Главный компонент называется родительским компонентом, а несколько компонентов, находящихся в родительском компоненте, называются дочерними компонентами.
Процесс размещения дочернего компонента называется вложением элементов React.
	6. React — это все о компонентах
Компоненты в реакции — это не что иное, как набор фрагментов кода, которые можно использовать повторно. Они похожи на функции Javascript, но работают изолированно и возвращают HTML-коды через реагирующий метод render(). В React.js есть два типа компонентов. Эти:
	7. Выражения в JSX
Не обязательно использовать JSX в реагирующем приложении. Но это определенно помогает писать в реагирующих приложениях. JSX — это не что иное, как html-код в файле Javascript. Это помогает React показывать больше полезных ошибок и предупреждающих сообщений.

const demoText = ‘Learning React’;
const element = <h1>This is demo text: {demoText}</h1>;
ReactDOM.render(
element,
document.getElementById(‘root’)
);

Любые допустимые выражения Javascript можно использовать внутри фигурных скобок, использованных выше.
	8. Создание функциональных компонентов
Функциональные компоненты написаны как обычная функция javascript. Он содержит «реквизит» (что означает свойства) в качестве параметра функции. Это называется функциональной составляющей.

function MyCompnent(props) {
return <h1>Hello, {props.name}</h1>;
}

	9. Реагировать на крючки
До введения хуков реакции состояние и некоторые другие функции использовались только в компонентах класса. Хуки — это просто функции javascript и имеют некоторые особенности, в отличие от функций javascript. Было трудно повторно использовать компоненты с отслеживанием состояния до введения хуков реакции.

const [count, setCount] = useState(0);

	10. Виртуальный дом
Виртуальный дом — это концепция программирования, которая означает объектную модель документа, созданную виртуально для сравнения с реальным или фактическим DOM. Об этом в основном говорят в известной библиотеке Javascript React. После сравнения двух DOM, если выполняется сравнение. Если реакция находит какое-либо различие между двумя DOM, предыдущая DOM обновляется информацией о виртуальной DOM. Этот процесс называется примирением.
\-\-\-\-\-\-\-\-\
Хуки
!Хуки — это функции, с помощью которых вы можете "подцепиться" к состоянию и методам жизненного цикла React из функциональных компонентов. Хуки не работают внутри классов — они дают вам возможность использовать React без классов.
(позволяет использовать состояние и другие возможности React без написания классов)
!Хук useState – с самого простого и важного хука – useState. Из самого названия становится понятно, что он связан с состоянием компонента. Именно благодаря ему у функциональных компонентов появилось состояние.
!Хук useContext – Чтобы передать какие-то данные в компонент есть способ – context. контекст позволяет передавать данные от родительского компонента к дочернему, минуя промежуточные.
!Хуки useEffect и useLayoutEffect – методы жизненного цикла служат для того, чтобы совершать какие-то операции на разных стадиях жизни компонента. Для этого у нас есть два хука – useEffect и useLayoutEffect. Они похожи между собой, за исключением небольшой разницы в рендеринге. В случае с useLayoutEffect React не запускает рендеринг построенного DOM дерева до тех пор, пока не отработает useLayoutEffect. Если же мы берём useEffect, то React сразу запускает рендеринг построенного DOM, не дожидаясь запуска useEffect.
!Хук useRef – прямая связь с узлами, когда необходимо обратиться к какому-то DOM-объекту напрямую.
!Хук useReducer – как аналог Redux в составе React. Этот хук позволяет вынести данные из компонентов.
!Хук useMemo – Этот хук позволяет не производить одни и те же вычисления много раз. 
!Хук useCallback – это функция, при каждом рендеринге запускается всё, что объявлено в ней. 
!Пользовательские хуки – это те же самые функции, которые внутри себя используют какие-либо из стандартных хуков. Единственное требование, которое здесь необходимо соблюдать – относиться к ним, как к хукам. То есть, соблюдать правила, что мы используем при работе с хуками: не вызывать их внутри условных конструкций (таких, как if или switch) и внутри циклов (например for), а также не использовать хуки внутри колбэков других хуков. 
\-\-\-\-\-\-\-\-\
Рендеринг компонентов
!Рендеринг — это процесс, в рамках которого React опрашивает ваши компоненты, требуя от них актуальное описание той секции пользовательского интерфейса, за которую они отвечают, основываясь на текущей комбинации пропсов (props) и состояния (state).
React начинает процесс рендеринга с корня дерева компонентов и циклически спускается вниз, чтобы найти все компоненты, помеченные как требующие обновления. Для каждого помеченного компонента React вызывает либо classComponentInstance.render() (для классовых компонентов), либо FunctionComponent() (для функциональных компонентов) и сохраняет результат рендеринга.
Результат рендеринга компонентов обычно представлен в виде JSX-кода, который затем компилируется и развертывается как JS-код, принимая вид серии вызовов React.createElement(). Функция createElement возвращает React-элементы, представляющие собой простые JS-объекты, описывающие желаемую структуру пользовательского интерфейса.
\-\-\-\-\-\-\-\-\
Компоненты высшего порядка
!Компонент высшего порядка — это функция, которая принимает компонент и возвращает новый компонент.
Компонент высшего порядка (HOC)-это продвинутая техника React для повторного использования логики компонентов. HOC сами по себе не являются частью API React. Это паттерн, который возникает из композиционной природы React. Конкретно, компонент более высокого порядка - это функция, которая принимает компонент и возвращает новый компонент.
Если обычный компонент преобразует пропсы в UI, то компонент высшего порядка преобразует компонент в другой компонент.
\-\-\-\-\-\-\-\-\
Оптимизация 
!Методы оптимизации производительности React
1. Сохранение состояния компонента там, где это необходимо, 
чтобы повторная отрисовка компонента происходила только тогда, когда это необходимо, мы можем извлечь часть кода, которая заботится о состоянии компонента, сделав ее локальной.
2. Компоненты Memoizing React для предотвращения ненужных повторных рендеров
Мемоизация — это стратегия оптимизации, которая кэширует операцию визуализации компонента, сохраняет результат в памяти и возвращает кэшированный результат для тех же входных данных.
3. Разделение кода в React с помощью динамического импорта
Благодаря разделению кода React позволяет нам разделить большой файл на несколько фрагментов с помощью динамического импорта с последующей ленивой загрузкой этих фрагментов по запросу с помощью React.lazy. Эта стратегия значительно улучшает производительность страницы сложного приложения React.
4. Виртуализация окон или списков в React
По концепции работы с окнами мы можем отображать в DOM только видимую для пользователя часть. Затем при прокрутке отображаются оставшиеся элементы списка, заменяя элементы, выходящие из области просмотра. Этот метод может значительно улучшить производительность рендеринга большого списка. И react-window, и react-virtualized — две популярные библиотеки, которые могут реализовать такую концепцию.
5. Ленивая загрузка изображений в React
Чтобы оптимизировать приложение, состоящее из нескольких изображений, мы можем избежать рендеринга всех изображений одновременно, чтобы сократить время загрузки страницы. При отложенной загрузке мы можем подождать, пока каждое из изображений не появится в окне просмотра, прежде чем визуализировать их в DOM.

\-\-\-\-\-\-\-\-\
Библиотеки, используемые вместе с React
1. React Query
Известно, что React Query, недостающая библиотека управления состоянием для React.
В документации к ней говорится: «Получайте, кэшируйте и обновляйте данные в ваших приложениях React, не затрагивая никакого "глобального состояния"».
Преимущества
    Автоматическое кэширование
    Автоматическое обновление данных в фоновом режиме
    Значительно сокращает объем кода
2. React Hook Form
React Hook Form - это современная библиотека обработки форм, которая может поднять эффективность работы вашей формы на совершенно новый уровень.
Преимущества
    Уменьшает объем кода
    Сокращает ненужный ре-рендеринг.
    Легко интегрируется с современными библиотеками пользовательского интерфейса (UI)
3. React Window
React Window используется для рендеринга длинных списков. Данный код рендерит только то, что вы видите на экране.
4. React LazyLoad
Ленивая загрузка - это техника, используемая для загрузки только того, что вам нужно. Таким образом, она повышает производительность, не расходуя без необходимости вычислительные мощности.
Преимущества
    Повышенная производительность
    Поддерживает рендеринг на стороне сервера
5. Почему вы выполняете рендеринг (Why Did You Render)
Why Did You Render, помогает нам найти проблемы с производительностью и решить их. Вы просто включаете его в любом компоненте, и он сообщает вам, почему именно происходит рендеринг.
6. Reselect
редьюсеры Redux могут хранить большое количество данных, и если вы передадите всё хранилище в какой-либо компонент, это приведет к тому, что он будет заново рендериться каждый раз, когда что-либо в этом хранилище будет обновляться.
Reselect решает эту проблему, меморизуя значения и передавая только то, что необходимо.
Преимущества
    Селекторы могут вычислять производные данные, что позволяет Redux хранить минимально возможное состояние.
    Селекторы эффективны. Селектор не пересчитывается, если один из его аргументов не изменился.
    Селекторы являются составными. Они могут быть использованы в качестве входных данных для других селекторов.
7. Deep Equal
это известная библиотека, которую можно использовать для сравнения. Это очень удобно. Ведь в JavaScript, несмотря на то, что два объекта могут иметь одинаковые значения, они считаются разными, поскольку указывают на разные области памяти.

\/+\/+\/+\/+\/+\/+\/
Redux
\-\-\-\-\-\-\-\-\
Redux — это инструмент для управления состоянием данных и пользовательским интерфейсом в приложениях JavaScript с большим количеством сущностей. Представляет собой библиотеку JavaScript.
\-\-\-\-\-\-\-\-\
Для чего нужен Redux
    --для управления состоянием приложения, работающего с большим количеством данных;
    --удобной замены встроенных средств работы с состоянием в React;
    --более легкого масштабирования приложения, его преобразования под разные задачи;
    --избавления от ошибок, связанных с беспорядком в объекте состояния;
    --предсказуемости и понятности работы приложения;
    --более простой отладки и доработки;
    --повышения производительности и работоспособности программы.
\-\-\-\-\-\-\-\-\    
!Основные концепции
Redux базируется на трех принципах, из которых следует характер работы с ним.
	1.Единый источник состояния. Все данные о состоянии приложения хранятся в одном месте, без копий. Глобальное состояние организовано как дерево объектов и называется state tree. Также используются термины «источник состояния» и «хранилище». Оба означают местонахождение глобального состояния. Единый источник нужен для централизации и отладки приложения. Работа становится проще, если данные находятся в одном месте.
	2.Доступ к состоянию — только для чтения. Глобальное состояние заблокировано для записи. Компоненты приложения могут читать из него, но не переписывать по своему желанию. Это предотвращает непредсказуемые изменения. Ситуаций, когда объект изменился, а функции об этом не узнали, не бывает. При изменениях в состояние нужно отправить действие (action). Специальный объект сообщит о произошедшем.
	3.Изменения — только через редукторы. Когда в состояние поступает действие, его обрабатывают редукторы, или редьюсеры (reducers). Это чистые функции — результат их выполнения зависит только от входных данных.
!Редукторы берут объект состояния компонента, который изменился, и действие. На их основе они генерируют новый объект состояния. Функции всегда создают новый объект. Если действие сложное, а приложение большое, для него могут запуститься несколько редукторов.
Результат работы редуктора — новый объект состояния с актуальными данными, рассчитанными на основе информации из объекта-действия. Он попадает в дерево состояний вместо старого.
\-\-\-\-\-\-\-\-\
Преимущества Redux
	1.Легкая работа с состоянием. Redux реализован просто и элегантно, мало весит и при этом эффективно управляет состоянием. Его основную функциональность можно уместить в десять строчек кода. Пользоваться Redux удобнее, чем самостоятельно писать менеджер состояний.
	2.Упрощение масштабирования. Redux часто используют в связке с React, потому что в React не очень удобный встроенный алгоритм для управления состояниями. Его особенности приводят к тому, что приложение становится тяжело масштабировать. Redux решает эту проблему.
	3.Простое изучение. Если разработчик уже знает один из основных фреймворков для JavaScript либо «чистый» JS, ему будет просто начать работу с Redux. Обучающие материалы и уроки находятся в открытом доступе.
	4.Множество полезных инструментов. Для Redux существуют вспомогательные библиотеки и инструменты, которые сильно облегчают работу с приложениями. Компоненты модифицируют модель, описанную выше, или помогают работать с ней более гибко. 

\/+\/+\/+\/+\/+\/+\/
TypeScript
\-\-\-\-\-\-\-\-\
Базовые принципы 
+++++
язык программирования, представленный Microsoft в 2012 году и позиционируемый как средство разработки веб-приложений, расширяющее возможности JavaScript
Это строго типизированный объектно-ориентированных язык, который компилируется в JavaScript. Он позволяет использовать хорошо известные практики и шаблоны объектно-ориентированного программирования, а так же проверяет код на этапе компиляции. Полученный JavaScript может выполнять в любой среде в которой работает JavaScript, то есть это самый обычный JavaScript.
\-\-\-\-\-\-\-\-\
отличия от JS
!Компиляция
Одна из неприятностей которую можно встретить при разработке на JavaScript — это опечатка или случайное переопределение глобальной переменной. Что можно обнаружить только на этапе выполнения программы. И это явно не экономит время разработки.
TypeScript при компиляции проверяет код на ошибки, что очевидно ускорит выявление подобных неприятностей.
!Строгая типизация
Основное преимущество TypeScript перед JavaScript в том, что TS дает разработчику возможность явно объявить типы переменных и структур данных. TypeScript проверит правильность типов и сообщит об ошибке до того, как код приложения уйдет в продакшен. TypeScript делает код управляемее.
!Улучшенное ООП
Например, TS позволяет применять модификаторы доступа public/protected/private. Они помогают более тонко настроить доступ к методам и данным объекта и сделать работу с классами эффективнее. Еще TypeScript позволяет типизировать данные и методы класса — и типизировать сам класс с помощью интерфейсов 
!Цель создания TypeScript — сделать JavaScript лучше. TypeScript добавляет в JavaScript типы, позволяя явно задавать их для всех структур данных. Это увеличивает читаемость кода и уменьшает количество ошибок в финальной сборке приложения.
Еще у TypeScript есть компилятор (транспайлер), который проверяет код на ошибки и помогает их исправить до выхода в продакшен.
TypeScript использует последние возможности JavaScript, которые поддерживают не все браузеры. Но при этом в TypeScript можно безопасно использовать весь потенциал JavaScript, не переживая за совместимость: в результате код будет скомпилирован в максимально совместимый со всеми браузерами JavaScript.
TypeScript легко начать применять в существующем проекте на JavaScript, постепенно обновляя старый код. Это позволяет легко перенести код на TypeScript, не уходя в затяжной рефакторинг. Такая опция критически важна в продуктовых командах, которые постоянно балансируют между выпуском новых фич и рефакторингом старого кода.

\/+\/+\/+\/+\/+\/+\/
Node.js
\-\-\-\-\-\-\-\-\
Node (или более формально Node.js) - кросплатформенная среда исполнения с открытым исходным кодом, которая позволяет разработчикам создавать всевозможные серверные инструменты и приложения используя язык JavaScript. Среда исполнения предназначена для использования вне контекста браузера (т.е. выполняется непосредственно на компьютере или на серверной ОС). Таким образом, среда исключает API-интерфейсы JavaScript для браузера и добавляет поддержку более традиционных OS API-интерфейсов, включая библиотеки HTTP и файловых систем.
С точки зрения веб-серверной разработки Node имеет ряд преимуществ:
    1.Отличная производительность! Node был разработан для оптимизации пропускной способности и масштабируемости в веб-приложениях и очень хорошо справляется со многими распространёнными проблемами веб-разработки (например, веб-приложения реального времени).
    2.Код написан на «обычном старом JavaScript», а это означает, что затрачивается меньше времени при написании кода для браузера и веб-сервера связанное с «переключением технологий» между языками.
    3.JavaScript является относительно новым языком программирования и имеет преимущества от улучшения дизайна языка по сравнению с другими традиционными языками для веб-серверов (например, Python, PHP, и т.д.). Многие другие новые и популярные языки компилируются/конвертируются в JavaScript, поэтому вы можете также использовать CoffeeScript, ClosureScript, Scala, LiveScript, etc.
    4.Менеджер пакетов Node (NPM) обеспечивает доступ к сотням тысяч многоразовых пакетов. Он также имеет лучшее в своём классе разрешение зависимостей и может также использоваться для автоматизации большинства инструментов построения.
    5.Он портативен, имеет версии для Microsoft Windows, OS X, Linux, Solaris, FreeBSD, OpenBSD, WebOS, и NonStop OS. Кроме того, он имеет хорошую поддержку среди многих хостинг-провайдеров, которые часто предоставляют конкретную инфраструктуру и документацию для размещения сайтов, работающих на Node.
    6.Он имеет очень активную стороннюю экосистему и сообщество разработчиков, которые всегда готовы помочь.
Вы можете использовать Node.js для создания простого веб сервера используя пакет Node HTTP.
\-\-\-\-\-\-\-\-\
Express - самый популярный веб-фреймворк для Node. Он является базовой библиотекой для ряда других популярных веб-фреймворков Node. Он предоставляет следующие механизмы:
    1.Написание обработчиков для запросов с различными HTTP-методами в разных URL-адресах (маршрутах).
    2.Интеграцию с механизмами рендеринга «view», для генерации ответов, вставляя данные в шаблоны.
    3.Установка общих параметров веб-приложения, такие как порт для подключения, и расположение шаблонов, которые используются для отображения ответа.
    4.«промежуточное ПО» для дополнительной обработки запроса в любой момент в конвейере обработки запросов.
\-\-\-\-\-\-\-\-\
Node.js в основном используется для создания быстрых и масштабируемых веб-приложений. При этом используется управляемая событиями неблокирующая модель ввода-вывода, что делает эту платформу простой и эффективной. Это отличное решение для разработки приложений реального времени, обрабатывающих большие объемы данных и выполняющихся на распределенных устройствах.
    1.Одностраничные приложения. Это веб-приложения, которые работают в браузере и не требуют повторной загрузки страницы при каждом ее использовании для получения новых данных. Некоторые примеры одностраничных приложений включают в себя приложения социальных сетей, электронную почту, приложения карт, текст в Интернете, инструменты для рисования и т. д.
    2.Приложения в режиме реального времени. Это веб-приложения, которые способствуют пользователям получать информацию сразу после публикации автором, а не требовать периодических проверок источника на наличие обновлений. Некоторые примеры RTA включают в себя приложения для обмена мгновенными сообщениями и комнаты чатов, многопользовательские онлайн-игры, которые можно играть в браузере, документы для совместной работы в сети, хранилище сообщества, приложения видеоконференций и т. д.
    3.Приложения потоковой передачи данных. Это приложения (или службы), которые отправляют данные или содержимое по мере их поступления (или создания), сохраняя подключение для продолжения загрузки дополнительных данных, содержимого или компонентов по мере необходимости. К некоторым примерам относятся приложения потоковой передачи видео и аудио.
    4.API REST. Это интерфейсы, которые предоставляют данные для взаимодействия с веб-приложением другого пользователя. Например, служба API календаря может предоставлять даты и время для концертного помещения, которое может использоваться веб-сайтом локальных событий другого пользователя.
    5.Готовые к просмотру приложения на стороне сервера (SSR) . Эти веб-приложения могут работать как на клиенте (в вашем браузере / внешнем интерфейсе), так и на сервере (внутренний), позволяя динамически отображать (создавать HTML) любое известное содержимое и быстро перехватывать неизвестное по мере его доступности. Их часто называют "изоморфными" или "универсальными" приложениями. Службы SSR используют методы SPA, поскольку им не нужно перезагружаться при каждом использовании. Тем не менее, SSR предлагают несколько преимуществ, которые могут быть или не быть важны для вас, например, включение содержимого вашего сайта в результаты поиска Google и предоставление изображения для предварительного просмотра, когда ссылки на ваше приложение публикуются в социальных сетях, таких как Twitter или Facebook. Потенциальным недостатком является то, что они требуют постоянной работы сервера Node.js. С точки зрения примеров, приложение для социальных сетей, поддерживающее события, которые пользователи захотят видеть в результатах поиска и социальных сетях, может извлечь выгоду из SSR, в то время как приложение для электронной почты может хорошо работать как SPA. Вы также можете запускать преобразованные сервером приложения, отличные от SPA, как например блог WordPress. Как видите, все может осложниться, вам просто стоит решить, что важно.
    6.Средства командной строки. Они позволяют автоматизировать повторяющиеся задачи, а затем распространить ваше средство по обширной экосистеме Node.js. Примером средства командной строки является cURL, под которым подразумевается клиентский URL и который используется для загрузки контента с URL-адреса Интернета. cURL часто используется для установки таких компонентов, как Node.js, в нашем случае менеджера версий Node.js.
    7.Программирование оборудования. Хотя Node.js не так популярен, как веб-приложения, в настоящее время Node.js пользуется все большей популярностью для использования в IoT, например, для сбора данных с датчиков, маяков, передатчиков, двигателей или всего, что генерирует большие объемы данных. Node.js может обеспечить сбор данных, анализ этих данных, обмен данными между устройством и сервером и принятие мер на основе анализа. NPM содержит более 80 пакетов для контроллеров Arduino, raspberry pi, Intel IoT Edison, различных датчиков и устройств Bluetooth.

\/+\/+\/+\/+\/+\/+\/
Webpack
\-\-\-\-\-\-\-\-\
!Webpack — это инструмент, позволяющий скомпилировать, например, JavaScript модули в единый JS-файл. Webpack также известен как сборщик модулей.
!Webpack генерирует статические ресурсы, которые представляют собой модули с зависимостями.
!этот пакет модулей создавался со следующими целями:
    1.Обеспечить беспрецедентную свободу кастомизации.
    2.Сократить время начальной загрузки.
    3.Для разделения деревьев зависимостей на фрагменты, которые загружаются по требованию.
    4.Чтобы позволить каждому статическому ресурсу быть модулем.
    5.Чтобы обеспечить интеграцию сторонних библиотек в качестве модулей.

!Во-первых, вам необходимо понять два основных принципа:
	1. В webpack модулем может быть любая сущность. Это касается и JS-файлов, и CSS, и изображений, и HTML. Следовательно, любой объект может быть разделен на небольшие, управляемые фрагменты для повторного использования.
	2. webpack загружает только то, что вам нужно, когда вам это нужно. Другие сборщики модулей обычно объединяют все модули для создания одного большого файла bundle.js. Такие файлы могут достигать 15 МБ для динамических веб-приложений, и их загрузка занимает много времени. В отличие от них, webpack генерирует несколько небольших файлов «bundle», что позволяет ему загружать части приложения асинхронно. Таким образом, пользователям не нужно ждать неоправданно долго, чтобы начать работу с приложением.

!Он также способен выполнять множество иных операций:
    --помогает собрать воедино ваши ресурсы
    --следит за изменениями и повторно выполняет задачи
    --может выполнить транспиляцию JavaScript следующего поколения до более старого стандарта JavaScript (ES5) с помощью Babel, что позволит использовать новейшие функции JavaScript, не беспокоясь о том, поддерживает их браузер или нет
    --может выполнить транспиляцию CoffeeScript в JavaScript
    --может конвертировать встроенные изображения в data:URI
    --позволяет использовать require() для CSS файлов
    --может запустить webpack-dev-server (в нём встроен локальный сервер и livereload (“живая перезагрузка браузера”))
    --может работать с Hot Module Replacement (замена горячего модуля)
    --может разделить выходной файл (output file) на несколько файлов, чтобы избежать медленной загрузки страницы из-за большого размера JS-файла
    --может выполнить Tree Shaking

Webpack не ограничивается одним лишь фронтендом, его также успешно применяют в бэкенд разработке на Node.js.

\/+\/+\/+\/+\/+\/+\/
Lint
\-\-\-\-\-\-\-\-\
 !это инструмент статического анализа кода, используемый для выявления ошибок программирования, ошибок, стилистических ошибок и подозрительных конструкций. Термин происходит от утилиты Unix , которая исследовала исходный код языка Си.
	!Линтер на основании заданных правил перерабатывает код за секунду:
    --расставляет нужные табы и пробелы;
    --проставляет точки с запятой и скобки в нужных местах;
    --в HTML делает красивую вложенную структуру тегов и выносит стили из тегов в отдельный блок в <style>;
    --в других языках может проставить большие буквы в названиях функций, чтобы было удобнее читать;
    --убирает лишние пробелы и пустые строки.
!Линтер помогает сделать код чище и понятнее для других программистов, которые будут его читать. Кроме того, он помогает искать баги и стилистические ошибки. 
!Например, для JavaScript есть JSLint, JSHint и ESlint — это всё линтеры, которые делают плюс-минус одно и то же и различаются в деталях.

\/+\/+\/+\/+\/+\/+\/
Docker
\-\-\-\-\-\-\-\-\
Docker — это проект с открытым исходным кодом для автоматизации развертывания приложений в виде переносимых автономных контейнеров, выполняемых в облаке или локальной среде.
	!Docker — это платформа контейнеризации с открытым исходным кодом, с помощью которой можно автоматизировать создание приложений, их доставку и управление. Платформа позволяет быстрее тестировать и выкладывать приложения, запускать на одной машине требуемое количество контейнеров.
	!Docker Compose является инструментом для определения и запуска контейнерных приложений.
	!Если конкретнее, Docker — это инструмент, с помощью которого разработчики, системные администраторы и все желающие могут легко запускать разные приложения в изолированных контейнерах на одном сервере.
Контейнеры не знают, что рядом развёрнуты другие контейнеры с приложениями, они полностью изолированы друг от друга. В каждом контейнере можно настроить окружение, необходимое именно для этого приложения.
В отличие от виртуальных машин, контейнеры не требуют серьёзных мощностей, что позволяет более эффективно использовать ресурсы сервера.
	!контейнер — это изолированный процесс, который работает со своим кусочком файловой системы, памятью, ядром и другими ресурсами. При этом он думает, что все ресурсы принадлежат только ему.
	!Особенности контейнеров:
    --Короткий жизненный цикл. Любой контейнер можно остановить, перезапустить или удалить. Данные, которые содержатся в контейнере, тоже пропадут. Поэтому при проектировании приложений, которые подходят для контейнеризации, используют правило: не хранить важные данные в контейнере. Такой подход проектирования называют Stateless.
    --Контейнеры маленькие и лёгкие, их объём измеряется в мегабайтах. Так получается, потому что в контейнер упаковывают лишь те процессы и зависимости ОС, которые необходимы для приложения. Легковесные контейнеры занимают мало места на диске и быстро запускаются.
    --Контейнеризация обеспечивает изоляцию процессов. Приложения, которые работают внутри контейнера, не имеют доступа к основной ОС.
    --Благодаря контейнерам можно перейти с монолита на микросервисную архитектуру.
    --Не нужно тратиться на гипервизор, и можно запустить больше контейнеров, чем ВМ на одних и тех же ресурсах.
    --Контейнеры хранятся в специальных репозиториях, и каждый контейнер содержит всё необходимое окружение для запуска приложения, благодаря чему можно автоматизировать развёртывание приложения на разных хостах.
	!какие преимущества даёт Docker.
    --Сообщество. Существует огромное хранилище контейнеров с открытым исходным кодом, и вы можете скачать готовый образ для конкретной задачи.
    --Гибкость. Docker позволяет создавать базовые шаблоны контейнеров (image) и использовать их повторно на различных хостах. Docker-контейнеры можно легко запустить как на локальном устройстве, так и в любой облачной инфраструктуре.
    --Скорость развёртывания. Шаблон контейнера содержит всё необходимое окружение и настройки для работы приложения, нам не нужно настраивать всё это каждый раз с нуля.
    --Нет проблемы с зависимостями и версиями пакетов. Docker позволяет упаковывать различные языки программирования и стек технологий в контейнер, чем избавляет от проблемы несовместимости разных библиотек и технологий в рамках одного хоста.
	 !в ядре Linux из коробки есть все необходимые механизмы для создания контейнеров:
    1.capabilities — позволяет выдать процессу часть расширенных прав, которые доступны только root. Например, разрешить удалять чужие файлы, завершать другие процессы (команда kill) или изменять атрибуты у файлов (команда chown);
    2.namespace — это абстракция в Linux, с помощью которой можно создавать своё изолированное окружение в ОС. То есть такую коробочку, в которой свои пользователи, своя сеть, свои процессы и всё остальное. При этом изменения в namespace видны только членам этого namespace. Есть шесть типов пространств имён (namespaces): IPC, Network, Mount, PID, User, UTS.
	!Docker Image
Образ — это шаблон для ваших будущих контейнеров. В образе описывается, что должно быть установлено в контейнере и какие действия нужно выполнить при старте контейнера.
В практической части вы будете использовать команду docker pull, чтобы загрузить busybox image из специального хранилища Docker образов — docker hub.
	!Docker Container
Контейнер — это исполняемый экземпляр образа (image). Его можно создавать, запускать, останавливать и удалять. Также можно подключать к контейнеру хранилище, объединять контейнеры одной или несколькими сетями и общаться с контейнерами, используя Docker API или CLI.
Увидеть список запущенных контейнеров можно через команду docker ps.
	!Docker Daemon
Docker-демон (dockerd) — фоновый процесс в операционной системе, который обрабатывает запросы Docker API и управляет объектами Docker: образами, контейнерами, сетями и томами.
	!Docker Client
Docker-клиент — инструмент командной строки (Comand Line Interface — CLI), через который пользователь взаимодействует с демоном.
Когда вы используете команду docker run, то Docker-клиент отправляет команду dockerd. Аналогичная история с другими командами docker <команда>.
	!Docker Hub
Docker Hub — это общедоступный Docker registry, то есть хранилище всех доступных Docker-образов. При необходимости можно разворачивать свои приватные Docker registry, размещать собственные реестры Docker и использовать их для извлечения образов.


На что ещё обращаем внимание:

    Хорошая техническая база, понимание "как оно вообще всё работает".
    Опыт коммерческой фронтенд-разработки от 2-х лет.
    Асинхронность, чистый код, алгоритмы и структуры данных, паттерны.

