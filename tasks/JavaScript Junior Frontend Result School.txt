https://www.youtube.com/watch?v=PLwrvZahiO4

I Theory

1. HTML and CSS.

+\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+
DOM (Document Object Model).
Объектная Модель Документа (DOM) – это программный интерфейс (API) для HTML и XML документов. DOM предоставляет структурированное представление документа и определяет то, как эта структура может быть доступна из программ, которые могут изменять содержимое, стиль и структуру документа. Представление DOM состоит из структурированной группы узлов и объектов, которые имеют свойства и методы.

+\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+
Cемантические теги — это теги со значением. Семантические теги четко описывают, что они означают, как браузеру, так и веб-разработчику. 
Хорошо для индексации.
Примеры семантических элементов: <form>, <table>, <article>. Они четко описывают, какого характера контент они содержат. В качестве примера не семантических элементов можно привести теги <div> и <span>. Они ничего не говорят о характере их контента.

Семантическая вёрстка — подход к разметке, который опирается не на содержание сайта, а на смысловое предназначение каждого блока и логическую структуру документа. 
несколько примеров семантических тегов.
<article>
    Значение: независимая, отделяемая смысловая единица, например комментарий, твит, статья, виджет ВК и так далее.
    Особенности: желателен заголовок внутри.
    Типовые ошибки: путают с тегами <section> и <div>.
<section>
    Значение: смысловой раздел документа. Неотделяемый, в отличие от <article>.
    Особенности: желателен заголовок внутри.
    Типовые ошибки: путают с тегами <article> и <div>.
<aside>
    Значение: побочный, косвенный для страницы контент.
    Особенности: может иметь свой заголовок. Может встречаться несколько раз на странице.
    Типовые ошибки: считать <aside> тегом для «боковой панели» и размечать этим тегом основной контент, который связан с окружающими его элементами.
<nav>
    Значение: навигационный раздел со ссылками на другие страницы или другие части страниц.
    Особенности: используется для основной навигации, а не для всех групп ссылок. Основной является навигация или нет — на усмотрение верстальщика. Например, меню в подвале сайта можно не оборачивать в <nav>. В подвале обычно появляется краткий список ссылок (например, ссылка на главную, копирайт и условия) — это не является основной навигацией, семантически для такой информации предназначен <footer> сам по себе.
    Типовые ошибки: многие считают, что в <nav> может быть только список навигационных ссылок, но согласно спецификации там может быть навигация в любой форме.
<header>
    Значение: вводная часть смыслового раздела или всего сайта, обычно содержит подсказки и навигацию. Чаще всего повторяется на всех страницах сайта.
    Особенности: этих элементов может быть несколько на странице.
    Типовые ошибки: использовать только как шапку сайта.
<main>
    Значение: основное, не повторяющееся на других страницах, содержание страницы.
    Особенности: должен быть один на странице, исходя из определения.
    Типовые ошибки: включать в этот тег то, что повторяется на других страницах (навигацию, копирайты и так далее).
<footer>
    Значение: заключительная часть смыслового раздела или всего сайта, обычно содержит информацию об авторах, список литературы, копирайт и так далее. Чаще всего повторяется на всех страницах сайта.
    Особенности: этих элементов может быть несколько на странице. Тег <footer> не обязан находиться в конце раздела.
    Типовые ошибки: использовать только как подвал сайта.

+\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+
CSS (Cascading Style Sheets «каскадные таблицы стилей») — формальный язык описания внешнего вида документа (веб-страницы), написанного с использованием языка разметки (чаще всего HTML или XHTML). Также может применяться к любым XML-документам, например, к SVG или XUL. 
CSS (Cascading Style Sheets, каскадные таблицы стилей) — язык описания внешнего вида HTML-документа. Это одна из базовых технологий в современном интернете. Практически ни один сайт не обходится без CSS, поэтому HTML и CSS действуют в единой связке.
Каскадные таблицы стилей работают с HTML, но это совершенно другой язык. HTML структурирует документ и упорядочивает информацию, а CSS взаимодействует с браузером, чтобы придать документу оформление. 

+\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+
CSS-селектор — Селектор (от англ. select — выбирать) — это шаблон, который позволяет обратиться к элементу или группе элементов веб-страницы, чтобы применить к ним стили CSS. Его указывают перед блоком со свойствами
Универсальный селектор
Он применяет стили ко всем элементам страницы и обозначается символом * (звёздочка). С его помощью удобно сбрасывать отступы и задавать значение box‑sizing для всех блочных элементов
Селектор по тегу (элементу)
Этот селектор CSS применяет стили ко всем элементам с одинаковым тегом. Например, для всех <div>, <h2>, <p> и так далее.
Селектор по идентификатору (id)
Селектор по идентификатору обозначается символом # (решётка) и применяет стили к элементу, для которого задан атрибут id с соответствующим значением. При этом у элемента может быть только один id, и этот id должен быть уникальным в пределах веб-страницы.
Селектор по классу (class)
CSS-селектор по классу выбирает элементы, для которых назначен атрибут class с соответствующим значением. При этом один элемент может принадлежать нескольким классам — в таком случае их перечисляют через пробел
Группа селекторов
CSS-селекторы можно сгруппировать, чтобы применить стили к нескольким группам и/или классам элементов. Для этого достаточно перечислить их через запятую

Выбор элементов по отношению и расположению
Есть группа селекторов, которые позволяют выбрать элемент по его отношению к другим элементами (родитель — потомок) и по расположению в DOM (Document Object Model).

Выбрать всех потомков

Чтобы обратиться ко всем потомкам В элемента A, независимо от уровня их вложенности, используют конструкцию A B (селекторы разделяют пробелом):

figure img {
    margin-bottom: 20px;
}

В примере выше мы устанавливаем всем изображениям внутри элемента figure значение нижних отступов 20 пикселей.
Выбрать потомков первого уровня

Если нужно применить CSS-стили к потомкам B элемента A только на первом уровне вложенности, то вместо пробела пишут символ >:

.container > img {
    margin-bottom: 40px;
}

Здесь мы задали изображениям внутри контейнера с классом .container значение нижних отступов 40 пикселей.
Выбрать все следующие элементы

Селектор A ~ B выбирает все элементы B, которые идут после A. Обратите внимание: «идут после», а не вложены в него. Например, так мы задали цвет фона #f2f3f5 всем карточкам, которые идут после блока из класса .about_us:

.about_us > .card {
    background-color: #f2f3f5;
}

Выбрать первый следующий элемент

Селектор A + B выбирает только первый элемент B, который следует за A:

.about_us + .card {
    background-color: #f2f3f5;
}

В этом примере цвет фона #f2f3f5 установится только для той карточки, которая идёт сразу после .about_us.

CSS-селекторы по атрибуту

Ещё один полезный инструмент — селекторы по атрибуту. Они позволяют выбрать элемент по имени атрибута, его значению или части значения. Кратко расскажем обо всех.
[attr]

Применяет стили к элементам, для которых задан этот атрибут:

[title] {
		font-weight: bold;
	}

[attr=value]

Работает по имени и значению атрибута:

[title="what_is"] {
		font-weight: normal;
	}

+\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+
Псевдоклассы и псевдоэлементы

Псевдокласс выбирает элементы, находящиеся в определённом состоянии или положении в иерархии DOM.

Вот несколько примеров таких состояний:

    на кнопку наведён курсор мыши;
    пользователь перешёл или не перешёл по ссылке;
    курсор установлен на поле ввода.

Например, так с помощью CSS можно увеличить размер ссылок, на которые пользователь навёл курсор:

a:hover {
		font-size: 20px;
	}
Вот список основных псевдоклассов:
Название	Состояние элемента
:hover	Наведён курсор
:focus	Элемент находится в фокусе (например, по нему кликнули мышью или его выбрали клавишей Tab)
:visited	Ссылка, которая была посещена
:active	Активный элемент (в промежутке времени между нажатием и отпусканием кнопки мыши)
:checked	Элементы radio, checkbox или option, которые были выбраны
:first-child	Первый потомок элемента
:last-child	Последний потомок элемента
:nth-child()	Каждый n-й потомок — число n передаётся в качестве аргумента
:last-nth-child()	Последние n потомков — число n передаётся в качестве аргумента
:read-write	Элементы, доступные для редактирования

Вес CSS-селектора, или специфичность

Для одного и того же элемента веб-страницы можно прописать сколько угодно стилей. Если в разных местах CSS-файла какому-то его свойству заданы разные значения, то браузер должен выбрать одно из них.

Обычно подключается правило, которое определено последним, но так происходит не всегда. Дело в том, что одни селекторы обладают более высокой специфичностью, чем другие.

Специфичность — это показатель, по которому браузер определяет, какие стили применить к элементу. Её можно представить в виде четырёх чисел 0.0.0.0, где каждый разряд — это вес, определяемый специальными правилами.

Вот эти правила:

    Наивысший приоритет — у стилей, прописанных в атрибуте style (1.0.0.0).
    На втором месте — селекторы по идентификатору (0.1.0.0).
    Затем идут три равноправные группы: селекторы по классу, атрибуту и псевдоклассы (0.0.1.0).
    На четвёртом месте — селекторы по тегу и псевдоэлементы (0.0.0.1).
    Комбинаторы ~, >, + и универсальный селектор * веса не добавляют.
    Вес псевдоклассов :is(), :has() и :not() равен весу самого специфичного селектора внутри скобок.

Чтобы определить самый «тяжёлый» селектор, браузер сначала взвешивает каждый, а затем сравнивает их поразрядно.

В CSS !important означает, что “это важно” (this is important), все последующие правила игнорируются и применяется правило !important. Это правило должно быть указано в конце строки, сразу после точки с запятой. p {color: green !important;}. Для баланса декларация !important (символ-разделитель "!" и ключевое слово "important" находятся после декларации) имеет преимущество над обычной декларацией.

Margin и Padding - это очень часто используемые свойства в CSS. Margin - пространство за его рамками, а Padding - это пространство внутри чего-либо.
padding — внутреннее пространство между содержимым элемента и его границей border.
margin — пространство от border, padding или контента до соседних элементов. Задаётся по такой же логике и тоже по часовой стрелке.

+\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+
Отступы margin-top и margin-bottom иногда объединяются в один, с размером равным наибольшему из них (или размеру одного, если они равны). Это поведение известно как схлопывание внешних отступов (margin collapsing). Обратите внимание, что отступы плавающих и абсолютно позиционированных элементов никогда не схлопываются
Схлопывание внешних отступов (только margin, padding не схлопывается!) — особенность блочной модели CSS, которая заключается в наложении вертикальных внешних отступов двух или более блочных элементов (которые могут быть или не быть соседями) для формирования одиночного внешнего отступа. Отступ, сформировавшийся в результате данного объединения, называется схлопнувшимся отступом.

Отмена схлопывания margin
Схлопывание не всегда требуется при вёрстке страницы, а в некоторых случаях вообще «ломает» дизайн. Поэтому следует знать, в каких случаях схлопывание не работает.

Схлопывание margin не срабатывает:

    для элементов с абсолютным позиционированием, т. е. таких, у которых position установлено как absolute или fixed;
    для обтекаемых элементов (для них свойство float задано как left или right);
    для строчных или строчно-блочных элементов (для них свойство display задано как inline или inline-block);
    для флекс-элементов (у родителя которых свойство display задано как flex или inline-flex);
    для элемента <html>.

Схлопывание не действует на дочерние элементы:

    если у родителя значение overflow задано как auto, hidden или scroll;
    если у родителя на стороне схлопывания задано свойство padding;
    если у родителя на стороне схлопывания задано свойство border.

Учтите, что свойства padding и border должны иметь размер больше нуля, к примеру, 1px.

+\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+
CSS препроцессор (CSS preprocessor) - это программа, которая имеет свой собственный синтаксис (syntax (en-US)), но может сгенерировать из него CSS код. Существует множество препроцессоров. Большинство из них расширяет возможности чистого CSS, добавляя такие опции как: примеси, вложенные правила, селекторы наследования и др. Эти особенности облегчают работу с CSS: упрощают чтение кода и его дальнейшую поддержку.
С препроцессором у вас 30 кнопок, в которых будет вот так:

border-radius: $defaultBorderRadius

А где-то в отдельном месте документа будет один раз написано:

$defaultBorderRadius: 7px;

Какие бывают препроцессоры CSS
Sass
Любопытно, что у Sass есть два синтаксиса:

    Sass — самый первый вариант, где не используются фигурные скобки, а всё сделано на отступах, как в Python.
    SCSS — в нём есть фигурные скобки, как в родном CSS, а ещё есть поддержка современных CSS-трюков, которые используются в разных браузерах. Этот формат появился после выхода LESS и стал ответом конкуренту.

LESS. В 2009 году другие программисты показали свою версию препроцессора, основанную на Sass. Они взяли за основу чистый CSS-синтаксис и добавили в него возможность использовать все расширения как в Sass. Технически это интереснее, чем простой Sass, но нельзя сказать, что это сильно круче, чем тот же SCSS.

Stylus и другие. Есть и другие препроцессоры — например, тот же Stylus. Принципиально он делает то же самое, но использует другой синтаксис, более лаконичный и простой.

Какой выбрать?

По сути все они делают одно и то же: упрощают работу с CSS-кодом, поэтому это вопрос вкуса и привычек. Если давать общие рекомендации, мы бы сделали так:

    Sass (SCSS) подойдёт тем, кто больше любит программирование, чем вёрстку.
    LESS понравится всем, кому приглянулся чистый CSS-синтаксис, но хочется сделать работу ещё проще.
    Stylus можно выбрать тем, кто ценит в коде лаконичность и минимализм.

Когда использовать препроцессоры?

Если у вас CSS-код занимает не больше одной-двух страниц, нет смысла использовать препроцессоры: настройка и описание кода займёт больше времени, чем сразу написать то, что нужно. А вот если у вас большой сайт с разным дизайном на странице или очень сложная CSS-вёрстка, то тут уже пригодятся препроцессоры.

Преимущества и недостатки препроцессоров

Так как все CSS-препроцессоры делают примерно одно и то же, только немного разными способами, то сильные и слабые стороны у них будут одни и те же:

✅ Хорошо подходят для больших проектов.

✅ Сильно расширяют возможности обычного CSS.

✅ Упрощают работу с однотипным кодом.

✅ Проще вносить изменения и поддерживать код в актуальном состоянии.

✅ Сразу видна логическая структура CSS, легко разобраться в том, из чего состоит каждый элемент.

❌ Нет смысла использовать в маленьких проектах и простых страницах.

❌ На выходе препроцессора получается CSS-код, который сложно прочитать человеку.

❌ Нужно изучать что-то кроме самого CSS.

❌ У каждого препроцессора свой синтаксис, и не получится быстро перейти от одного к другому.


+\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+
БЭМ (Блок, Элемент, Модификатор) — компонентный подход к веб-разработке. В его основе лежит принцип разделения интерфейса на независимые блоки. Он позволяет легко и быстро разрабатывать интерфейсы любой сложности и повторно использовать существующий код, избегая «Copy-Paste». Это список правил для фронтенд-проектов. Основные сущности, которыми оперирует БЭМ, — блок, элемент и модификатор.

Блок — это абсолютно независимый компонент страницы. Он отвечает только за отображение элементов — то есть, например, у него не может быть внешних отступов margin. Блоки могут включать в себя другие блоки. Имя блока совпадает с именем селектора по классу:

Элемент — это часть блока, которая имеет смысл только внутри своего блока и отдельно от него не используется. Имя селектора включает имя класса и — через двойное подчёркивание — имя элемента.

Модификатор — это сущность, которая описывает атрибуты блока или элемента: положение, состояние, поведение. Для разделения слов в именах всех сущностей используются дефисы. Модификатор в селекторе именуется через одно подчёркивание после имени элемента или блока.

Существуют разные вариации подходов к именованию: CamelCase (каждое слово в названии пишется с прописной буквы), Two Dashes (модификаторы отделяются двумя дефисами) и другие.

Преимущества БЭМ

    Понятная структура проекта. Просто взглянув на названия селекторов, можно понять, как устроен проект и за что отвечает тот или иной класс.
    Одновременная работа над разными компонентами. Правила именования обеспечивают уникальность селекторов, вероятность повториться в именах модификаторов мала. Поэтому разработчики могут работать одновременно и не создавать коллизий.
    Быстрый онбординг новых сотрудников. Изучение проекта требует меньше времени, потому что компоненты по БЭМ документируют сами себя.
    Высокая скорость разработки. Понятная структура облегчает рефакторинг, а возможность переиспользования — создание новых проектов.
    Безопасность при привлечении сторонних сотрудников. Проект строится из независимых блоков, поэтому каждому задействованному разработчику знать подробности всего проекта не нужно. Специалисты могут работать в рамках отдельных компонентов. Это позволяет привлекать сторонних специалистов на большие проекты.
    Гибкость. Можно применять не всю методологию, а только часть. И даже это может сделать работу над проектом удобнее.

Минусы БЭМ

1. Использование блоков там, где можно обойтись без них. На небольших проектах код для маленьких компонентов (например, логотипа или единственной кнопки), созданный в соответствии с принципами БЭМ, может выглядеть громоздко.

2. Длинные имена элементов и модификаторов. Названия сущностей из нескольких слов могут серьёзно усложнить названия селекторов, и разработчику, не привыкшему к БЭМ, разбираться в них будет сложно. Поэтому при разработке приходится продумывать имена более тщательно, чтобы плюсы БЭМ не превращались в минусы.

3. Необходимость знать БЭМ, чтобы работать с проектом и понимать принятую на проекте схему именования селекторов. Любые технологии требуют изучения, а именование в БЭМ поначалу может казаться избыточным. Но это тот случай, когда «лучше день потерять, потом за пять минут долететь».

4. Расплывчатость понятия «по БЭМ». Обратная сторона гибкости БЭМ — сложно быстро объяснить, какие именно правила из методологии вы используете.

+\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+
display

Свойство display, которое определяет, как элемент должен быть показан в документе.
Свойство display имеет много разных значений. Обычно, используются только три из них: none, inline и block, потому что когда-то браузеры другие не поддерживали.
Значение none
Самое простое значение. Элемент не показывается, вообще. Как будто его и нет.
Значение block
Блочные элементы располагаются один над другим, вертикально (если нет особых свойств позиционирования, например float).
Блок стремится расшириться на всю доступную ширину. Можно указать ширину и высоту явно.
Значение inline
Элементы располагаются на той же строке, последовательно.
Ширина и высота элемента определяются по содержимому. Поменять их нельзя.
Значение inline-block
Это значение – означает элемент, который продолжает находиться в строке (inline), но при этом может иметь важные свойства блока.
Как и инлайн-элемент:
    Располагается в строке.
    Размер устанавливается по содержимому.
Во всём остальном – это блок, то есть:
    Элемент всегда прямоугольный.
    Работают свойства width/height.
nline-table	Определяет, что элемент является таблицей как при использовании тега <table>, но при этом таблица является встроенным элементом и происходит ее обтекание другими элементами, например, текстом. 											
list-item	Элемент выводится как блочный и добавляется маркер списка.
run-in	Устанавливает элемент как блочный или встроенный в зависимости от контекста. 											
table	Определяет, что элемент является блочной таблицей подобно использованию тега <table>. 

+\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+
2. Javascript

+\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+
Область видимости переменной

Часть программы, в которой доступен тот или иной идентификатор, называют областью видимости переменной.
В зависимости от области видимости в JavaScript различают локальные (functional scope) и глобальные (global scope) переменные. Локальные создаются внутри функции и доступны только в её пределах. А глобальные объявляются вне функций и видны в любой точке программы. Именно в работе с областью видимости и заключаются различия между var и let.
Переменная var, созданная вне функции, действует как глобальная переменная — она доступна из любой части скрипта.
Если же создать переменную с помощью var внутри функции, то она будет локальной, то есть доступной только в этой функции
Это позволяет создавать переменные с одинаковыми названиями и обращаться к внешним переменным через специальный объект window
"-" var
Отсутствие блочной области видимости. Var-переменная, созданная в блоке if‑else или цикле, доступна за пределами своего блока.
Повторное объявление. Переменные var можно создавать повторно, и компилятор не будет ругаться.

«Поднятие» переменной, или hoisting. 
Все переменные var считаются объявленными перед запуском скрипта. При этом они остаются undefined до тех пор, пока не выполнится код инициализации.
При создании переменной в JavaScript через VAR, она инициализируются со значением undefined. Это и есть «Hoisting». Интерпретатор JavaScript присваивает переменой значение undefined по умолчанию, во время так называемой фазы «Создания».

Как работает let и чем она отличается от var

Ключевое слово let лишено недостатков своего предшественника. Переменные, объявленные с его помощью, нельзя объявить повторно — программа выдаст ошибку. Let-переменные тоже «всплывают», но при попытке обратиться к ним до инициализации вы получите ошибку ReferenceError.
Но главное — такие переменные имеют блочную область видимости. А значит, они доступны только внутри того блока {}, в котором были созданы

Объявление констант с помощью оператора const

С помощью ключевого слова const создаются константы. Например, физические и математические величины.
Попытка изменить значение константы приведёт к ошибке. Поэтому их стоит использовать для хранения данных, которые должны оставаться неизменными.

+\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+
Логические операторы

|| (ИЛИ)
В случае, если какой-либо из аргументов true, он вернёт true, в противоположной ситуации возвращается false.
ИЛИ "||" находит первое истинное значение
Оператор || выполняет следующие действия:

    Вычисляет операнды слева направо.
    Каждый операнд конвертирует в логическое значение. Если результат true, останавливается и возвращает исходное значение этого операнда.
    Если все операнды являются ложными (false), возвращает последний из них.

Значение возвращается в исходном виде, без преобразования.
Другими словами, цепочка ИЛИ || возвращает первое истинное значение или последнее, если такое значение не найдено.

&& (И)
В традиционном программировании И возвращает true, если оба аргумента истинны, а иначе – false
И «&&» находит первое ложное значение
Оператор && выполняет следующие действия:

    Вычисляет операнды слева направо.
    Каждый операнд преобразует в логическое значение. Если результат false, останавливается и возвращает исходное значение этого операнда.
    Если все операнды были истинными, возвращается последний.

Другими словами, И возвращает первое ложное значение. Или последнее, если ничего не найдено.

Вышеуказанные правила схожи с поведением ИЛИ. Разница в том, что И возвращает первое ложное значение, а ИЛИ –  первое истинное.
Приоритет оператора И && больше, чем ИЛИ ||, так что он выполняется раньше.

! (НЕ)
Оператор принимает один аргумент и выполняет следующие действия:

    Сначала приводит аргумент к логическому типу true/false.
    Затем возвращает противоположное значение.
В частности, двойное НЕ !! используют для преобразования значений к логическому типу:
То есть первое НЕ преобразует значение в логическое значение и возвращает обратное, а второе НЕ снова инвертирует его. В конце мы имеем простое преобразование значения в логическое.

Приоритет НЕ ! является наивысшим из всех логических операторов, поэтому он всегда выполняется первым, перед && или ||.

+\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+
Function Expression в сравнении с Function Declaration

Function Declaration: функция объявляется отдельной конструкцией «function…» в основном потоке кода.
// Function Declaration
function sum(a, b) {
  return a + b;
}

Function Expression: функция, созданная внутри другого выражения или синтаксической конструкции. В данном случае функция создаётся в правой части «выражения присваивания» =:

// Function Expression
let sum = function(a, b) {
  return a + b;
};
Function Expression создаётся, когда выполнение доходит до него, и затем уже может использоваться.
Function Declaration может быть вызвана раньше, чем она объявлена.
В строгом режиме, когда Function Declaration находится в блоке {...}, функция доступна везде внутри блока. Но не снаружи него.

    Функции – это значения. Они могут быть присвоены, скопированы или объявлены в любом месте кода.
    Если функция объявлена как отдельная инструкция в основном потоке кода, то это “Function Declaration”.
    Если функция была создана как часть выражения, то это “Function Expression”.
    Function Declaration обрабатываются перед выполнением блока кода. Они видны во всём блоке.
    Функции, объявленные при помощи Function Expression, создаются только когда поток выполнения достигает их.

+\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+
Массивы

Массив – это специальная структура данных, которая предназначена для хранения упорядоченных коллекций значений.

Создание массива

Создавать новые массивы в JavaScript можно двумя способами:

    с использованием литерала, т.е. посредством квадратных скобок [] и перечислением в них элементов через запятую;
    путем создания нового экземпляра класса Array.

Пример создания пустого массива:

// посредством литерала массива
const arr = [];
// с использованием конструктора Array()
const otherArr = new Array();

Доступ к элементам

Получение доступа к элементу массива выполняется через квадратные скобки, внутрь которых нужно поместить индекс.

Так как индексы нумеруются с 0, то для получение первого, второго и третьего элемента нужно использовать индексы 0, 1 и 2.
При попытке получить доступ к несуществующему элементу возвращается undefined

Массивы являются объектами

Массивы в JavaScript не являются каким-то определённым типом данных. Это объект, у которого прототипом является Array.

так как массивы являются объектами, то при его копировании, передаётся не он сам, а ссылка на него:

const names = ['Иван', 'Вася'];
const copyNames = names;
copyNames[1] = 'Петр';
console.log(names); // ['Иван', 'Петр']

Создать копию массива можно следующими способами:

const names = ['Иван', 'Вася'];
// клонирование массива с помощью slice
const cloneNames1 = names.slice();
// с помощью оператора spread
const cloneNames2 = [...names];
// с помощью Array.from
const cloneNames3 = Array.from(names);


Перебор массива

Перебор элементов можно выполнить различными способами.

1. Использовать цикл for:

const students = ['Петя', 'Вася', 'Коля', 'Максим'];
for (let i = 0, length = students.length; i < length; i++) {
  console.log( students[i] );
}

2. Метод forEach:

students.forEach((item) => {
  console.log(item);
});

3. Цикл for..of:

for (let item of students) {
  console.log( item );
}

Если нужно с индексами:

const nums = ['One', 'Two', 'Three'];
// 1 способ
for (let i = 0, length = nums.length; i < length; i++) {
  console.log( `students[${i}] = ${students[i]}`);
}
// 2 способ
nums.forEach(function(item, index, array) {
  // item – элемент, index – его индекс, array – массив
  console.log( `nums[${index}] = ${item}` );
});

Поиск элемента в массиве

Найти элемент в массиве можно с помощью метода indexOf():

const disks = ['500Gb', '1Tb', '2Tb'];
const index = disks.indexOf('1Tb'); // 1

Метод lastIndexOf() выполняет то же самое что indexOf(), только осуществляет это с конца

Удаление элементов массива

Удаление элемента массива с помощью delete делает его неопределённым (пустым). Длина массива при этом не изменяется.

const nums = ['One', 'Two', 'Three', 'Four', 'Five'];
delete nums[2]; // ['One', 'Two', , 'Four', 'Five']

Если нужно конкретно удалить элемент из массива, то можно воспользоваться методом splice.

Пример удаления элемента массива по индексу:

const nums = ['One', 'Two', 'Three', 'Four', 'Five'];
nums.splice(2, 1); // ['One', 'Two', 'Four', 'Five']
По значению это можно сделать так:
const nums = ['One', 'Two', 'Three', 'Four', 'Five'];
for (let i = 0; i < nums.length; i++) {
  if (nums[i] === 'Three') {
    nums.splice(i--, 1);
  }
}

С помощью filter():

const nums = ['One', 'Two', 'Three', 'Four', 'Five'];
const result = nums.filter(value => value !== 'Three');
console.log(result); // ['One', 'Two', 'Four', 'Five']

Добавление и удаление элементов

В JavaScript для добавления и удаления элементов имеются следующие методы:

    push() – для добавления одного или нескольких элементов в конец массива;
    unshift() – для добавления одного или нескольких элементов в начало массива;
    pop() – для удаления последнего элемента;
    shift() – для удаления первого элемента.

Пример использования методов:

const planets = ['Меркурий'];
// добавим в конец 2 элемента
planets.push('Земля', 'Марс'); // ["Меркурий", "Земля", "Марс"]
// добавим в начало 1 элемент
planets.unshift('Венера'); // ["Венера", "Меркурий", "Земля", "Марс"]
// удалим последний элемент
planets.pop(); // ["Венера", "Меркурий", "Земля"]
// удалим первый элемент
planets.shift(); // ["Меркурий", "Земля"]

Методы push() и unshift() в качестве результата возвращают количество элементов в массиве, а pop и unshift - удаленный элемент:

const list = ['One'];
console.log(list.push('Two', 'Three')); // 3
console.log(list.unshift('Four')); // 4
console.log(list.pop()); // "Four"
console.log(list.shift()); // "One"

Шпаргалка по методам массива:

    Для добавления/удаления элементов:
        push (...items) – добавляет элементы в конец,
        pop() – извлекает элемент с конца,
        shift() – извлекает элемент с начала,
        unshift(...items) – добавляет элементы в начало.
        splice(pos, deleteCount, ...items) – начиная с индекса pos удаляет deleteCount элементов и вставляет items.
        slice(start, end) – создаёт новый массив, копируя в него элементы с индекса start до end (не включая end).
        concat(...items) – возвращает новый массив: копирует все члены текущего массива и добавляет к нему items. Если какой-то из items является массивом, тогда берутся его элементы.

    Для поиска среди элементов:
        indexOf/lastIndexOf(item, pos) – ищет item, начиная с позиции pos, и возвращает его индекс или -1, если ничего не найдено.
        includes(value) – возвращает true, если в массиве имеется элемент value, в противном случае false.
        find/filter(func) – фильтрует элементы через функцию и отдаёт первое/все значения, при прохождении которых через функцию возвращается true.
        findIndex похож на find, но возвращает индекс вместо значения.

    Для перебора элементов:
        forEach(func) – вызывает func для каждого элемента. Ничего не возвращает.

    Для преобразования массива:
        map(func) – создаёт новый массив из результатов вызова func для каждого элемента.
        sort(func) – сортирует массив «на месте», а потом возвращает его.
        reverse() – «на месте» меняет порядок следования элементов на противоположный и возвращает изменённый массив.
        split/join – преобразует строку в массив и обратно.
        reduce/reduceRight(func, initial) – вычисляет одно значение на основе всего массива, вызывая func для каждого элемента и передавая промежуточный результат между вызовами.

    Дополнительно:
        Array.isArray(arr) проверяет, является ли arr массивом.

Пожалуйста, обратите внимание, что методы sort, reverse и splice изменяют исходный массив.

+\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+
Деструктурирующее присваивание

В JavaScript есть две чаще всего используемые структуры данных – это Object и Array.

    Объекты позволяют нам создавать одну сущность, которая хранит элементы данных по ключам.
    Массивы позволяют нам собирать элементы данных в упорядоченный список.

Деструктурирующее присваивание – это специальный синтаксис, который позволяет нам «распаковать» массивы или объекты в несколько переменных, так как иногда они более удобны.

Деструктуризация также прекрасно работает со сложными функциями, которые имеют много параметров, значений по умолчанию и так далее.

Деструктуризация массива

Вот пример деструктуризации массива на переменные:

// у нас есть массив с именем и фамилией
let arr = ["Ilya", "Kantor"];

// деструктурирующее присваивание
// записывает firstName = arr[0]
// и surname = arr[1]
let [firstName, surname] = arr;

alert(firstName); // Ilya
alert(surname);  // Kantor

Пропускайте элементы, используя запятые

Нежелательные элементы массива также могут быть отброшены с помощью дополнительной запятой:

// второй элемент не нужен
let [firstName, , title] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

alert( title ); // Consul

Если мы хотим не просто получить первые значения, но и собрать все остальные, то мы можем добавить ещё один параметр, который получает остальные значения, используя оператор «остаточные параметры» – троеточие ("..."):

let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

// rest это массив элементов, начиная с 3-го
alert(rest[0]); // Consul
alert(rest[1]); // of the Roman Republic
alert(rest.length); // 2

Переменная rest является массивом из оставшихся элементов.

Значения по умолчанию

Если в массиве меньше значений, чем в присваивании, то ошибки не будет. Отсутствующие значения считаются неопределёнными:

let [firstName, surname] = [];

alert(firstName); // undefined
alert(surname); // undefined

Если мы хотим, чтобы значение «по умолчанию» заменило отсутствующее, мы можем указать его с помощью =:

// значения по умолчанию
let [name = "Guest", surname = "Anonymous"] = ["Julius"];

alert(name);    // Julius (из массива)
alert(surname); // Anonymous (значение по умолчанию)

Значения по умолчанию могут быть гораздо более сложными выражениями или даже функциями. Они выполняются, только если значения отсутствуют.

Деструктуризация объекта

Деструктурирующее присваивание также работает с объектами.

Синтаксис:

let {var1, var2} = {var1:…, var2:…}

Вложенная деструктуризация

Если объект или массив содержит другие вложенные объекты или массивы, то мы можем использовать более сложные шаблоны с левой стороны, чтобы извлечь более глубокие свойства.

В приведённом ниже коде options хранит другой объект в свойстве size и массив в свойстве items. Шаблон в левой части присваивания имеет такую же структуру, чтобы извлечь данные из них:

let options = {
  size: {
    width: 100,
    height: 200
  },
  items: ["Cake", "Donut"],
  extra: true
};

// деструктуризация разбита на несколько строк для ясности
let {
  size: { // положим size сюда
    width,
    height
  },
  items: [item1, item2], // добавим элементы к items
  title = "Menu" // отсутствует в объекте (используется значение по умолчанию)
} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
alert(item1);  // Cake
alert(item2);  // Donut

Итого деструктуризация

    Деструктуризация позволяет разбивать объект или массив на переменные при присвоении.

    Полный синтаксис для объекта:

let {prop : varName = default, ...rest} = object

Cвойство prop объекта object здесь должно быть присвоено переменной varName. Если в объекте отсутствует такое свойство, переменной varName присваивается значение по умолчанию.

Свойства, которые не были упомянуты, копируются в объект rest.

Полный синтаксис для массива:

let [item1 = default, item2, ...rest] = array

Первый элемент отправляется в item1; второй отправляется в item2, все остальные элементы попадают в массив rest.

Можно извлекать данные из вложенных объектов и массивов, для этого левая сторона должна иметь ту же структуру, что и правая.

+\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+
Планирование: setTimeout и setInterval

Мы можем вызвать функцию не в данный момент, а позже, через заданный интервал времени. Это называется «планирование вызова».

Для этого существуют два метода:

    setTimeout позволяет вызвать функцию один раз через определённый интервал времени.
    setInterval позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени.

Эти методы не являются частью спецификации JavaScript. Но большинство сред выполнения JS-кода имеют внутренний планировщик и предоставляют доступ к этим методам. В частности, они поддерживаются во всех браузерах и Node.js.

setTimeout

Синтаксис:
let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...);

Параметры:

func|code
    Функция или строка кода для выполнения. Обычно это функция. По историческим причинам можно передать и строку кода, но это не рекомендуется.
delay
    Задержка перед запуском в миллисекундах (1000 мс = 1 с). Значение по умолчанию – 0.
arg1, arg2…
    Аргументы, передаваемые в функцию 

setInterval

Метод setInterval имеет такой же синтаксис как setTimeout:

let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...);

Все аргументы имеют такое же значение. Но отличие этого метода от setTimeout в том, что функция запускается не один раз, а периодически через указанный интервал времени.

Чтобы остановить дальнейшее выполнение функции, необходимо вызвать clearInterval(timerId).

Следующий пример выводит сообщение каждые 2 секунды. Через 5 секунд вывод прекращается:

// повторить с интервалом 2 секунды
let timerId = setInterval(() => alert('tick'), 2000);

// остановить вывод через 5 секунд
setTimeout(() => { clearInterval(timerId); alert('stop'); }, 5000);

+\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+
Promise 

Объект Promise используется для отложенных и асинхронных вычислений.

Promise — объект JavaScript, который занимается обработкой асинхронного кода. Они позволяют откладывать блоки кода до момента выполнения или отклонения действия. Вместо передачи обратных вызовов в функцию они прикрепляются к концу промиса, обеспечивая лучшую читаемость и возможность применения цепочек.
По умолчанию код в JavaScript выполняется последовательно (в одном потоке, синхронно). То есть таким образом, когда каждая следующая операция ждёт завершения предыдущей.
Вообще говоря, promises (дословно — «обещания») — это обёртки для функций обратного вызова (callback). Их можно использовать для упорядочивания синхронных и асинхронных действий.

Создание промиса

Начинается процесс написания промиса с его создания. Осуществляется это с помощью конструктора, т.е. с new Promise():

const promise = new Promise((resolve, reject) => {
  // асинхронный код
});

Состояния, в которых может находиться промис

Промис начинается с состояния ожидания (state: "pending"). Оно говорит о том, что он ещё не выполнен (результат undefined).

Промис завершается после вызова resolve() или reject(). При этом его состояние переходит соответственно в выполнено (state: "fulfilled") или отклонено (state: "rejected").

Внутрь функций resolve() или reject() можно поместить аргумент, который затем будет доступен соответственно в then() или catch().

// сдал ли экзамен
const passexam = true;
// промис
const result = new Promise((resolve, reject) => {
  setTimeout(() => {
    passexam ? resolve('Папа подарил 100$.') : reject('Папа не подарил 100$.');
  }, 5000);
});

result
  .then(value => {
    console.log(result);
    console.log(value);
  })
  .catch(value => {
    console.log(result);
    console.error(value);
  });

Методы промисов

У каждого промиса есть определённый набор методов, которые мы можем использовать:

    then – выполняется, когда промис завершился успешно (после вызова функции resolve());
    catch – вызывается, если промис завершается ошибкой (после вызова reject());
    finally – выполняется в любом случае после завершения промиса, вне зависимости от конечного состояния.

Цепочка промисов

Цепочка промисов – это простая концепция, в основу которой положено то, что методы промисов тоже в качестве результата возвращают промис. А так как они возвращают промис, то мы для них в свою очередь тоже можем вызвать методы и т.д. Таким образом, мы можем создавать цепочку из промисов, каждый из которых выполняется только после того как завершился предыдущий.

По простому цепочка промисов позволяет очень компактно записать код для последовательного выполнения нескольких асинхронных задач, каждая из которых должна выполняется после завершения предыдущей.

+\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+
Async/Await

Существует специальный синтаксис для работы с промисами, который называется «async/await».
 
Асинхронные функции

Начнём с ключевого слова async. Оно ставится перед функцией, вот так:

async function f() {
  return 1;
}

У слова async один простой смысл: эта функция всегда возвращает промис. Значения других типов оборачиваются в завершившийся успешно промис автоматически.

Например, эта функция возвратит выполненный промис с результатом 1:

async function f() {
  return 1;
}

f().then(alert); // 1

Можно и явно вернуть промис, результат будет одинаковым:

async function f() {
  return Promise.resolve(1);
}

f().then(alert); // 1

Так что ключевое слово async перед функцией гарантирует, что эта функция в любом случае вернёт промис. Согласитесь, достаточно просто? Но это ещё не всё. Есть другое ключевое слово – await, которое можно использовать только внутри async-функций.
Await

Синтаксис:

// работает только внутри async–функций
let value = await promise;

Ключевое слово await заставит интерпретатор JavaScript ждать до тех пор, пока промис справа от await не выполнится. После чего оно вернёт его результат, и выполнение кода продолжится.

В этом примере промис успешно выполнится через 1 секунду:

async function f() {

  let promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve("готово!"), 1000)
  });

  let result = await promise; // будет ждать, пока промис не выполнится (*)

  alert(result); // "готово!"
}

f();

В данном примере выполнение функции остановится на строке (*) до тех пор, пока промис не выполнится. Это произойдёт через секунду после запуска функции. После чего в переменную result будет записан результат выполнения промиса, и браузер отобразит alert-окно «готово!».

Обратите внимание, хотя await и заставляет JavaScript дожидаться выполнения промиса, это не отнимает ресурсов процессора. Пока промис не выполнится, JS-движок может заниматься другими задачами: выполнять прочие скрипты, обрабатывать события и т.п.

Итого Async/Await

Ключевое слово async перед объявлением функции:

    Обязывает её всегда возвращать промис.
    Позволяет использовать await в теле этой функции.

Ключевое слово await перед промисом заставит JavaScript дождаться его выполнения, после чего:

    Если промис завершается с ошибкой, будет сгенерировано исключение, как если бы на этом месте находилось throw.
    Иначе вернётся результат промиса.

Вместе они предоставляют отличный каркас для написания асинхронного кода. Такой код легко и писать, и читать.

Хотя при работе с async/await можно обходиться без promise.then/catch, иногда всё-таки приходится использовать эти методы (на верхнем уровне вложенности, например). Также await отлично работает в сочетании с Promise.all, если необходимо выполнить несколько задач параллельно.

+\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+
Event Loop (цикл событий)

Модель событийного цикла (event loop) называется так потому, что отслеживает новые события в цикле:

while(queue.waitForMessage()){
  queue.processNextMessage();
}

queue.waitForMessage ожидает поступления задач, если очередь пуста.

Идея событийного цикла очень проста. Есть бесконечный цикл, в котором движок JavaScript ожидает задачи, исполняет их и снова ожидает появления новых.

Общий алгоритм движка:

    1.Пока есть задачи:
        выполнить их, начиная с самой старой
    2.Бездействовать до появления новой задачи, а затем перейти к пункту 1

Примеры задач:

    Когда загружается внешний скрипт <script src="...">, то задача — это выполнение этого скрипта.
    Когда пользователь двигает мышь, задача — сгенерировать событие mousemove и выполнить его обработчики.
    Когда истечет таймер, установленный с помощью setTimeout(func, ...), задача — это выполнение функции func.
    И так далее.

Может так случиться, что задача поступает, когда движок занят чем-то другим, тогда она становится в очередь.

Очередь, которую формируют такие задачи, называют «очередью макрозадач».

Например, когда движок занят выполнением скрипта, пользователь может передвинуть мышь, тем самым вызвав появление события mousemove, или может истечь таймер, установленный setTimeout, и т.п. Эти задачи формируют очередь.

Задачи из очереди исполняются по правилу «первым пришел — первым ушел». Когда браузер заканчивает выполнение скрипта, он обрабатывает событие mousemove, затем выполняет обработчик, заданный setTimeout, и так далее.

Помимо макрозадач, существуют микрозадачи.

Микрозадачи приходят только из кода. Обычно они создаются промисами: выполнение обработчика .then/catch/finally становится микрозадачей. Микрозадачи также используются «под капотом» await, т.к. это форма обработки промиса.

Также есть специальная функция queueMicrotask(func), которая помещает func в очередь микрозадач.

Более подробный алгоритм событийного цикла (упрощенный):

    Выбрать и исполнить старейшую задачу из очереди макрозадач (например, «script»).
    Исполнить все микрозадачи:

    пока очередь микро задач не пуста: выбрать из очереди и исполнить старейшую микрозадачу

    Отрисовать изменения страницы, если они есть.
    Если очередь макрозадач пуста — подождать, пока появится макрозадача.
    Перейти к шагу 1.

Чтобы добавить в очередь новую макрозадачу:

    используйте setTimeout(f) с нулевой задержкой.

События пользовательского интерфейса и сетевые события в промежутках между микрозадачами не обрабатываются: микрозадачи исполняются непрерывно одна за другой.

Event loop регулирует последовательность исполнения контекстов — стек. 
Стек вызовов — это очередь LIFO (Last In, First Out).
Он формируется, когда сработало событие или была вызвана функция. Реакция на событие помещается в очередь исполнения, в event loop, который последовательно, с каждым циклом выполняет попадающий в него код. При этом привязанная к событию функция вызывается следующей после текущего контекста исполнения.

В JavaScript постоянно работают связанные между собой синхронная и асинхронная очереди выполнения. Синхронная — стек — формирует очередь и пробрасывает в асинхронную — event loop — вызовы функций, которые будут выполнены после текущего запланированного исполняемого контекста.

Чтобы данные находились в консистентном состоянии, каждая функция должна быть выполнена до конца. Это обусловлено однопоточностью JavaScript и некоторыми другими особенностями, например характерными для функциональных языков программирования замыканиями. Поэтому единственный поток представлен в виде очереди контекстов исполнения, в которой и происходит «вклинивание» функций, прошедших через цикл событий.


+\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+
Bind(), Call(), and Apply()

Пример:

Для того чтобы разобраться со всеми этими методами, мы создадим объект person с двумя свойствами и методом. Метод будет задан функцией showFullName(), использующей ключевое слово this.
Создание объекта person
JavaScript
const person = {
  firstname: 'James',
  lastname: 'Murray',
  showFullName: function(){
    return this.firstname + ' ' + this.lastname;
  }
}

Кроме того, нам понадобится функция getSkills(), которая у нас будет существовать отдельно от объекта person:
Функция getSkills()
JavaScript
function getSkills(s1, s2){
   console.log(this.showFullName() +' has skills: '+s1+', '+s2);
}
getSkills('HTML/CSS', 'JavaScript');
person.getSkills('HTML/CSS', 'JavaScript');

Эта функция выводит некоторую конформацию о навыках нашего объекта, используя его собственную функцию showFullName() и передаваемые в нее параметры. Мы будем использовать методы bind(), call() и apply() для того, чтобы иметь возможность вызвать функцию getSkills() для нашего объекта person.
+++
Метод bind() создаёт новую функцию, которая при вызове устанавливает в качестве контекста выполнения this предоставленное значение. В метод также передаётся набор аргументов, которые будут установлены перед переданными в привязанную функцию аргументами при её вызове.

С английского bind переводится, как связывать. То есть этот метод позволяет связать наш объект person с ключевым словом this во внешней функции через вспомогательную функцию.

Вспомогательной функцию назовем  personSkills, и запишем в нее вызов глобальной функции getSkills, передав через метод bind() наш объект person. Теперь ключевое слово this указывает на объект person, который мы передали в качестве аргумента в bind(). Код теперь выглядит так:

let personSkills = getSkills.bind(person); 
personSkills('HTML/CSS', 'JavaScript');
//или 2-м способом, указав параметры вызова функции сразу 
let personSkills = getSkills.bind(person, 'HTML/CSS', 'JavaScript'); 
personSkills();

Обратите внимание на то, что метод bind() всегда возвращает новую функцию. Он создает копию getSkills() и сообщает механизму JavaScript: «Каждый раз, когда вызывается эта копия getSkills(), установите ключевое слово this для ссылки на person во время ее выполнения». Это отличает bind()  от методов call() и apply(), которые ждут нас впереди.

Последнее небольшое замечание о bind(): мы можем вызвать bind()  только один раз для определенного объекта. Попытка использовать возвращаемую им фунцию для другого объекта ничего не даст. 

+++
Метод call() вызывает функцию с заданным контекстом. Иначе говоря, вы привязываете функцию к объекту, как если бы она ему принадлежала. 

Отличием метода call() от bind() является то, что нет необходимости создавать вспомогательную функцию для того, чтобы передать в качестве this нужный объект. 

getSkills.call(person, 'PHP', 'Python'); //James Murray has skills: PHP, Python

В отличие от bind(), call() не копирует функцию. Он позволяет передавать объект в качестве this и любые аргументы, а затем немедленно вызывает функцию.

+++
Методы apply() и call() практически идентичны при работе с выставлением значения this, за исключением того, что вы передаёте параметры функции в apply() как массив, в то время, как в call(), параметры передаются в индивидуальном порядке.
Метод apply() вызывает функцию с указанным значением this и аргументами, предоставленными в виде массива (либо массивоподобного объекта).
Это значит, что при вызове apply() для нашей функции getSkills() параметры нужно передать в квадратных скобках, как массив - и все. Результат:

getSkills.apply(person, ['C++', 'C#']); //James Murray has skills: C++, C#

Вот, собственно, и все, что касается применения методов bind(), call() и apply() для связывания this объекта и внешней функции. Однако практическое использование этих методов не исчерпывается только лишь этой ситуацией. Например, эти методы с успехом можно применять для различных действий с массивами или псевдомассивами (аргументами функций или коллекциями HTML-элементов).


+\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+
3 способа клонирования объектов в JavaScript

const food = { beef: '?', bacon: '?' }

// "Spread"
{ ...food }
const cloneFood = { ...food };
С помощью spread можно клонировать объект. Обратите внимание, что копия будет неглубокой. Клонируются только приметивные типы данных, объекты так же ссылками.


// "Object.assign"
Object.assign({}, food)
const cloneFood = Object.assign({}, food);
Также создает неглубокую копию объекта.

// "JSON"
JSON.parse(JSON.stringify(food))
const cloneFood = JSON.parse(JSON.stringify(food))
Этот способ предоставляет глубокую копию. Стоит упомянуть, что это быстрый и грязный способ глубокого клонирования объекта. В качестве более надежного решения рекомендуется использовать что-то вроде lodash.

Lodash DeepClone или JSON?

    JSON.stringify/parse работает только с литералом Number, String и Object без функции или свойства Symbol.
    deepClone работает со всеми типами, а функция и символ копируются по ссылке.


+\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+
Символ (Symbol) – примитивный тип данных, использующийся для создания уникальных идентификаторов.

Символы создаются вызовом функции Symbol(), в которую можно передать описание (имя) символа.

Даже если символы имеют одно и то же имя, это – разные символы. Если мы хотим, чтобы одноимённые символы были равны, то следует использовать глобальный реестр: вызов Symbol.for(key) возвращает (или создаёт) глобальный символ с key в качестве имени. Многократные вызовы команды Symbol.for с одним и тем же аргументом возвращают один и тот же символ.

Символы имеют два основных варианта использования:

    «Скрытые» свойства объектов.

    Если мы хотим добавить свойство в объект, который «принадлежит» другому скрипту или библиотеке, мы можем создать символ и использовать его в качестве ключа. Символьное свойство не появится в for..in, так что оно не будет нечаянно обработано вместе с другими. Также оно не будет модифицировано прямым обращением, так как другой скрипт не знает о нашем символе. Таким образом, свойство будет защищено от случайной перезаписи или использования.

    Так что, используя символьные свойства, мы можем спрятать что-то нужное нам, но что другие видеть не должны.

    Существует множество системных символов, используемых внутри JavaScript, доступных как Symbol.*. Мы можем использовать их, чтобы изменять встроенное поведение ряда объектов. Например, в дальнейших главах мы будем использовать Symbol.iterator для итераторов, Symbol.toPrimitive для настройки преобразования объектов в примитивы и так далее.

Технически символы скрыты не на 100%. Существует встроенный метод Object.getOwnPropertySymbols(obj) – с его помощью можно получить все свойства объекта с ключами-символами. Также существует метод Reflect.ownKeys(obj), который возвращает все ключи объекта, включая символьные. Так что они не совсем спрятаны. Но большинство библиотек, встроенных методов и синтаксических конструкций не используют эти методы.

+\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+
Распространение события

Когда некоторый объект инициирует событие, то оно не просто возникает на нём, а распространяется в документе определённым образом.
Это распространение является двунаправленным: от window к целевому элементу и обратно.

Согласно стандарту, оно делится на 3 фазы:

    Фаза погружения или захвата – от window к родителю цели (цель – это объект, который инициировал это событие).
    Фаза цели – событие на цели.
    Фаза всплытия – обратно, от родителя цели к window.

Стандарт DOM Events описывает 3 фазы прохода события:

    Фаза погружения (capturing phase) – событие сначала идёт сверху вниз.
    Фаза цели (target phase) – событие достигло целевого(исходного) элемента.
    Фаза всплытия (bubbling stage) – событие начинает всплывать.

Самое главное для нас, когда событие путешествует по документу, то браузер вызывает обработчики элементов, через которые оно проходит.

Всплытие

Принцип всплытия очень простой.
Когда на элементе происходит событие, обработчики сначала срабатывают на нём, потом на его родителе, затем выше и так далее, вверх по цепочке предков.
Этот процесс называется «всплытием», потому что события «всплывают» от внутреннего элемента вверх через родителей подобно тому, как всплывает пузырёк воздуха в воде.

Почти все события всплывают.
Ключевое слово в этой фразе – «почти».
Например, событие focus не всплывает. В дальнейшем мы увидим и другие примеры. Однако, стоит понимать, что это скорее исключение, чем правило, всё-таки большинство событий всплывают.

event.target

Всегда можно узнать, на каком конкретно элементе произошло событие.
Самый глубокий элемент, который вызывает событие, называется целевым элементом, и он доступен через event.target.
Отличия от this (=event.currentTarget):
    event.target – это «целевой» элемент, на котором произошло событие, в процессе всплытия он неизменен.
    this – это «текущий» элемент, до которого дошло всплытие, на нём сейчас выполняется обработчик.

Например, если стоит только один обработчик form.onclick, то он «поймает» все клики внутри формы. Где бы ни был клик внутри – он всплывёт до элемента <form>, на котором сработает обработчик.

При этом внутри обработчика form.onclick:
    this (=event.currentTarget) всегда будет элемент <form>, так как обработчик сработал на ней.
    event.target будет содержать ссылку на конкретный элемент внутри формы, на котором произошёл клик.

Прекращение всплытия

Всплытие идёт с «целевого» элемента прямо наверх. По умолчанию событие будет всплывать до элемента <html>, а затем до объекта document, а иногда даже до window, вызывая все обработчики на своём пути.
Но любой промежуточный обработчик может решить, что событие полностью обработано, и остановить всплытие.
Для этого нужно вызвать метод event.stopPropagation().

Погружение

Существует ещё одна фаза из жизненного цикла события – «погружение» (иногда её называют «перехват»). Она очень редко используется в реальном коде, однако тоже может быть полезной.



