!!!!!!!!
АЛГОРИТМЫ:
Алгоритм — это совокупность последовательных операций, направленных на решение определенной задачи.

\-\-\-\-\-\-\-\-\
big O notation
Нотация Big O — это способ представить временную и пространственную сложность алгоритма.

    Сложность времени: время, необходимое алгоритму для завершения выполнения.
    Пространственная сложность: память, занимаемая алгоритмом.

Существует несколько выражений (обозначений), которые представляют временную сложность алгоритма.
    O(1): Постоянная временная сложность. Это идеальный случай.
    O(log n): логарифмическая временная сложность. Если log(n) = x тогда это то же самое, что 10^x
    O(n): линейная временная сложность. Время увеличивается с количеством входных данных линейным образом. Например, если один вход занимает 1 мс, 4 входа потребуют 4 мс для выполнения алгоритма.
    O (n ^ 2): квадратичная временная сложность. В основном это происходит в случае вложенных циклов.
    O(n!): Факторная временная сложность. Это наихудший сценарий, которого следует избегать.

Вы должны попытаться написать свой алгоритм так, чтобы он мог быть представлен первыми тремя обозначениями. И последних двух следует избегать как можно чаще.

\-\-\-\-\-\-\-\-\
Сложность алгоритма

Для оценки сложности и скорости работы алгоритма используют так называемую «О-нотацию» или «О-большое».
Эта запись имеет вид O(n), где n – это количество операций, которое предстоит выполнить алгоритму. Важное замечание: O(n) всегда описывает худший возможный случай выполнения алгоритма. Это дает нам гарантию, что наш алгоритм никогда не будет работать медленнее O(n).
Скорость работы алгоритмов измеряется не в секундах, а в темпе роста количества операций. Т.е. нас интересует, насколько быстро возрастает время выполнения алгоритма с увеличением размера входных данных.

\-\-\-\-\-\-\-\-\
оптимизация 

+++++
Рекурсия

Функция, вызывающая саму себя, является рекурсией. Думайте об этом как об альтернативе циклу.
+++++
Смена алгоритма

возможно, есть алгоритмы, которые делают ту же самую задачу, но с меньшей сложностью. Например, можно попробовать перейти от O(N2) к O(N log N) или к O(N). Тогда можно найти альтернативы, которые будут работать с той же сложностью, но именно на ваших данных показывать лучшую производительность.
+++++
Оптимизация алгоритма

Если лучших вариантов нет, посмотрите на реализацию текущего алгоритма. Постарайтесь уменьшить количество итераций, проходов по коллекциям и массивам. То есть N-1 проход — это быстрее, чем N проходов, хотя в O-нотации получается одна и та же сложность.
Если в вашем сервисе используется сложная математика, которая занимает время, попытайтесь её упростить. Однажды мы искали точки на плоскости, ближайшие к заданной. Для формулы вычисления расстояния нам нужен был квадратный корень: Math.sqrt(dx**2 + dy**2). Но для поиска ближайшей точки достаточно было сравнивать квадраты расстояний: dx**2 + dy**2. Это даст тот же самый ответ, но при этом мы избавимся от медленного вычисления корня.
Посмотрите внимательно на свои сложные вычисления — возможно, у вас получится применить такой же подход. 
+++++
Вынос инвариантов на уровень выше

Бывает, что на каждой итерации вы постоянно проверяете или вычисляете одно и то же выражение, которое в следующей итерации не изменится. 
+++++
Досрочный выход из цикла

Иногда мы уже знаем результат нашего выражения, и нам не обязательно совершать поиск по всему массиву,
+++++
Предвычисление

Иногда некоторые константы можно посчитать заранее. 

+++++
Алгоритм линейного поиска
+++++
Алгоритм бинарного поиска

!!!!!!!!
JAVASCRIPT:
\-\-\-\-\-\-\-\-\
Решение задачи,
????????????????
 
\-\-\-\-\-\-\-\-\
общие вопросы по теории 
+++++
базовые типы

В JavaScript существует шесть основных типов данных, которые можно разделить на три основные категории: примитивные (или первичные), составные (или ссылочные) и специальные типы данных. String, Number и Boolean являются примитивными типами данных. Object, Array и Function (все типы объектов) являются составными типами данных. Тогда как Undefined и Null являются специальными типами данных.
+++++
коллекции

Сейчас мы знаем о следующих сложных структурах данных:
    Object Объекты для хранения именованных коллекций.
    Array Массивы для хранения упорядоченных коллекций.

Map
Map – это коллекция ключ/значение, как и Object. Но основное отличие в том, что Map позволяет использовать ключи любого типа. Map может использовать объекты в качестве ключей.
Методы и свойства:
    new Map() – создаёт коллекцию.
    map.set(key, value) – записывает по ключу key значение value.
    map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.
    map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.
    map.delete(key) – удаляет элемент (пару «ключ/значение») по ключу key.
    map.clear() – очищает коллекцию от всех элементов.
    map.size – возвращает текущее количество элементов.
Перебор Map
Для перебора коллекции Map есть 3 метода:
    map.keys() – возвращает итерируемый объект по ключам,
    map.values() – возвращает итерируемый объект по значениям,
    map.entries() – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of.

Set
Объект Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.
Его основные методы это:
    new Set(iterable) – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый Set.
    set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
    set.delete(value) – удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false.
    set.has(value) – возвращает true, если значение присутствует в множестве, иначе false.
    set.clear() – удаляет все имеющиеся значения.
    set.size – возвращает количество элементов в множестве.

Основная «изюминка» – это то, что при повторных вызовах set.add() с одним и тем же значением ничего не происходит, за счёт этого как раз и получается, что каждое значение появляется один раз.

Итого коллекции
Map – коллекция пар ключ-значение.
Отличия от обычного объекта Object:
    Что угодно может быть ключом, в том числе и объекты.
    Есть дополнительные методы, свойство size.

Set – коллекция уникальных значений, так называемое «множество».

Перебор Map и Set всегда осуществляется в порядке добавления элементов, так что нельзя сказать, что это – неупорядоченные коллекции, но поменять порядок элементов или получить элемент напрямую по его номеру нельзя.

WeakMap это специальный вид словаря, ключами которого могут быть только объекты, причём ссылки на них в WeakMap являются слабыми (не учитываются сборщиком мусора (garbage collector GC)). Интерфейс WeakMap совпадает с Map, единственное отличие - ключи WeakMap нельзя итерировать.
WeakSet это специальный вид коллекции, элементами которой могут быть только объекты. Ссылки на эти объекты в WeakSet являются слабыми (не учитываются сборщиком мусора (garbage collector GC)).
Основные отличия от Set:
    WeakSet это коллекция объектов ( примитивные значения не могут быть добавлены).
    WeakSet нельзя итерировать. А также нельзя получить список (итератор) элементов.

+++++
ООП
Объектно-ориентированное программирование (ООП) – это парадигма программирования, основанная на концепции классов и объектов. Она используется для структурирования программы на основе объектов, обычно называемых классами.
В ES6 был добавлен синтаксический сахар class. Класс – это абстрактное представление объекта, который облегчает использование ООП в JavaScript. 
При создании объекта из класса с помощью ключевого слова new, JavaScript внутренне вызывает метод конструктора, который инициализирует публичные и приватные свойства класса.
По умолчанию все свойства, объявленные в классе, являются публичными. Их можно вызывать и изменять вне класса.
Символ # указывает на то, что это свойство является приватным для класса, и только методы, объявленные внутри класса, могут получить к нему доступ. Приватные свойства должны быть объявлены до их использования.
        
class User {
	#password;
	constructor(name, userName, password) {
		this.name = name;
		this.userName = userName;
		this.#password = password;
	}
	login(userName, password) {	
		if (userName === this.userName && password === this.#password) {
			console.log('Login Successfully');
		} else {
			console.log('Authentication Failed!!');
		}	
	}
	setPassword(newPassword) {
		this.#password = newPassword;
	}	
};

const user = new User('Test testov', test_testov, 'password:)');
user.login('nehal_mahida', 'password:)'); // Login Successfully
console.log(user.name); // Nehal Mahida
console.log(user.password); // undefined
console.log(user.#password); // Syntax Error
user.setPassword('new_password:)');
user.login('nehal_mahida', 'password:)'); // Authentication Failed!!
user.login('nehal_mahida', 'new_password:)'); // Login Successfully 

!Наследование
При наследовании один класс получает свойства и методы другого класса. Класс, который наследует свойство, называется подклассом или дочерним классом. Класс, свойства которого наследуются, называется суперклассом или родительским классом.
Наследование является основной парадигмой ООП. Преимуществом наследования является возможность повторного использования написанного кода. Когда дочерний класс наследует методы от родительского класса, нам не нужно переписывать уже написанные методы, которые были в родительском классе.

Ключевое слово extends используется для установления отношений родитель-ребенок между двумя классами.
Подкласс имеет доступ ко всем публичным и защищенным членам суперкласса. Кроме того, он может иметь свои собственные свойства и методы. Так мы можем достичь повторного использования через наследование. 
Ключевое слово super – это специальное ключевое слово. Вызов super в конструкторе дочернего класса вызывает конструктор родительского.

!Инкапсуляция
Инкапсуляция определяется как связывание данных и методов в единое целое для защиты от доступа извне, подобно тому как таблетка содержит лекарство внутри своей оболочки.
В контексте класса к некоторым свойствам нельзя получить прямой доступ извне класса и необходимо вызвать соответствующий метод для этих свойств.
Это похоже на создание метода getter/setter для private свойств, которые объявляются в классе.

!Абстракция
Люди часто путают инкапсуляцию с абстракцией. Абстракция – демонстрация только основных вещей и сокрытие внутренней реализации.
Рассмотрим пример с автомобилем. Автомобиль выполняет некоторые действия, такие как старт, движение и остановка. Каждое действие приводит к результату. Плюс, эти действия имеют определенные поддействия, которые скрыты от вас, но вам не нужно заботиться об этих поддействиях. Например, пользователь не должен понимать, как работает зажигание или как поступает бензин, а важно знать, что есть кнопка старт, которая запускает двигатель.

!Полиморфизм
Полиморфизм уменьшает дублирование участков кода. Существуют два типа использования полиморфизма:
    Полиморфизм во время компиляции
    Полиморфизм во время выполнения
Перегрузка функций – это тип полиморфизма во время компиляции. Этот тип создает более одной функции с одинаковым именем и разными параметрами или типами. Но перегрузка функций не поддерживается в JavaScript, потому что при создании функций с одинаковыми именами JavaScript переопределит последнюю функцию.
Переопределение методов – это тип полиморфизма во время выполнения. Например, используется для переопределения методов родительского класса в дочернем классе. 
\-\-\-\-\-\-\-\-\
асинхронный JS
+++++
Выполнение JS-кода — однопоточное. Это значит, что в конкретный момент времени движок может выполнять не более одной строки кода. То есть вторая строка не будет выполнена, пока не выполнится первая.
Такое выполнение кода (строка за строкой) называется синхронным.
Стек вызовов
При вызове какой-то функции она попадает в так называемый стек вызовов.
Стек — это структура данных, в которой элементы упорядочены так, что последний элемент, который попадает в стек, выходит из него первым (LIFO: last in, first out). Стек похож на стопку книг: та книга, которую мы кладём последней, находится сверху.
Управление тем, как должны вызываться функции Web API, берёт на себя цикл событий (Event loop).
Цикл событий отвечает за выполнение кода, сбор и обработку событий и выполнение подзадач из очереди.
Заметьте, что стек вызовов и очередь задач называются именно стеком и очередью. Потому что вызовы из стека работают по принципу «последний зашёл, первый вышел» (LIFO: last in, first out), а в очереди — по принципу «первый зашёл, первый вышел» (FIFO: first in, first out).
Очередь — структура данных, в которой элементы упорядочены так, что первый попавший в очередь элемент покидает её первым.
Таким образом цикл событий работает с асинхронным кодом — то есть таким, который выполняется не построчно.
Callback (колбэк, функция обратного вызова) — функция, которая вызывается в ответ на совершение некоторого события.
Таким образом колбэк — это первый способ обработать какое-либо асинхронное действие.
Изначально колбэки были единственным способом работать с асинхронным кодом в JavaScript. Большая часть асинхронного API Node.js была написана именно на колбэках и создана для использования с колбэками.
Это, в принципе, логично — ментальная модель достаточно простая: «выполни эту функцию, когда случится это событие».
Однако у колбэков есть неприятный минус, так называемый ад колбэков (callback hell).

!Промис — это объект-обёртка для асинхронного кода. Он содержит в себе состояние: вначале pending («ожидание»), затем — одно из: fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»).
В понятиях цикла событий промис работает так же, как колбэк: функция, которая должна выполниться (resolve или reject), находится в окружении Web API, а при наступлении события — попадает в очередь задач, откуда потом — в стек вызова.
В асинхронных задачах есть разделение между макрозадачами и микрозадачами. Колбэки в промисах попадают в очередь микрозадач, тогда как колбэк в setTimeout() — в очередь макрозадач. Но здесь и сейчас мы в такие детали уходить не будем.
Промисы придумали, чтобы организовывать асинхронный код последовательно.
Промисы оказались удобными, и появился даже такой термин как «промисификация» — когда асинхронную функциональность на колбэках превращали в промисы.
Однако промисы — это тоже не серебряная пуля. У них есть несколько недостатков:
    Код не такой лаконичный, как мог быть.
    В цепочке промисов, как на примере (со стрелочными функциями), невозможно выставить брейкпоинт, потому что нет тела функции. Приходится раскрывать функцию.
    Стек ошибок может содержать в себе then.then.then.then....
    Вложенные условия сильно увеличивают количество кода и ухудшают читаемость.
Promise проблемы:
    Нуждаемся в обратном вызове для каждого .then.
    Вместо try/catch приходится использовать .catch для обработки ошибок.
    Организация циклов с множественными Promise в последовательности бросает вызов.

Для решения этих проблем придумали асинхронные функции.
!Если коротко, асинхронные функции — функции, которые возвращают промисы.
Связка async/await
Внутри асинхронных функций можно вызывать другие асинхронные функции, без каких-либо then() или колбэков, с помощью ключевого слова await.
!Плюсы async/await
Код чище и короче. У нас больше нет цепочек из then(), вместо этого мы получаем плоскую структуру, которая по виду похожа на синхронный код.
Условия и вложенные конструкции становятся чище и проще читаются.
Мы можем обрабатывать ошибки с try-catch. Как и с синхронным кодом, обработка ошибок сводится к оборачиванию опасных операций в try-catch
!!!!!!!!
TYPESCRIPT:
\-\-\-\-\-\-\-\-\
Базовые принципы 
+++++
язык программирования, представленный Microsoft в 2012 году и позиционируемый как средство разработки веб-приложений, расширяющее возможности JavaScript
Это строго типизированный объектно-ориентированных язык, который компилируется в JavaScript. Он позволяет использовать хорошо известные практики и шаблоны объектно-ориентированного программирования, а так же проверяет код на этапе компиляции. Полученный JavaScript может выполнять в любой среде в которой работает JavaScript, то есть это самый обычный JavaScript.
\-\-\-\-\-\-\-\-\
отличия от JS
!Компиляция
Одна из неприятностей которую можно встретить при разработке на JavaScript — это опечатка или случайное переопределение глобальной переменной. Что можно обнаружить только на этапе выполнения программы. И это явно не экономит время разработки.
TypeScript при компиляции проверяет код на ошибки, что очевидно ускорит выявление подобных неприятностей.
!Строгая типизация
Основное преимущество TypeScript перед JavaScript в том, что TS дает разработчику возможность явно объявить типы переменных и структур данных. TypeScript проверит правильность типов и сообщит об ошибке до того, как код приложения уйдет в продакшен. TypeScript делает код управляемее.
!Улучшенное ООП
Например, TS позволяет применять модификаторы доступа public/protected/private. Они помогают более тонко настроить доступ к методам и данным объекта и сделать работу с классами эффективнее. Еще TypeScript позволяет типизировать данные и методы класса — и типизировать сам класс с помощью интерфейсов 
!Цель создания TypeScript — сделать JavaScript лучше. TypeScript добавляет в JavaScript типы, позволяя явно задавать их для всех структур данных. Это увеличивает читаемость кода и уменьшает количество ошибок в финальной сборке приложения.
Еще у TypeScript есть компилятор (транспайлер), который проверяет код на ошибки и помогает их исправить до выхода в продакшен.
TypeScript использует последние возможности JavaScript, которые поддерживают не все браузеры. Но при этом в TypeScript можно безопасно использовать весь потенциал JavaScript, не переживая за совместимость: в результате код будет скомпилирован в максимально совместимый со всеми браузерами JavaScript.
TypeScript легко начать применять в существующем проекте на JavaScript, постепенно обновляя старый код. Это позволяет легко перенести код на TypeScript, не уходя в затяжной рефакторинг. Такая опция критически важна в продуктовых командах, которые постоянно балансируют между выпуском новых фич и рефакторингом старого кода.

\-\-\-\-\-\-\-\-\ 
Utility types
TypeScript Utility Types - это набор встроенных типов, которые можно использовать для манипулирования типами данных в коде. 
TypeScript обеспечивает несколько служебных типов для упрощения преобразований общего типа. Эти утилиты доступны глобально.
!Awaited
Awaited<T> - это специальный тип, который может быть использован для обозначения типа, который будет возвращен из асинхронной функции. 
!Partial
Partial<T> - делает все свойства объекта типа T необязательными. 
!Required
Required<T> - делает все свойства объекта типа T обязательными.
!Readonly
Readonly<T> - делает все свойства объекта типа T доступными только для чтения. 
!Record
Record<Keys, Type> - создает тип, который является записью с ключами,
!Pick
Pick<T, K extends keyof T> - выбирает свойства объекта типа T с ключами, указанными в K
!Omit
Omit<T, K extends keyof T> - выбирает свойства объекта типа T, исключая те, которые указаны в K

!!!!!!!!
REACT:
!React — это библиотека JavaScript с открытым кодом для создания внешних пользовательских интерфейсов. В отличие от других библиотек JavaScript, предоставляющих полноценную платформу приложений, React ориентируется исключительно на создание представлений приложений через инкапсулированные единицы (называются компонентами), которые сохраняют состояние и генерируют элементы пользовательского интерфейса.
\-\-\-\-\-\-\-\-\
Хуки
!Хуки — это функции, с помощью которых вы можете "подцепиться" к состоянию и методам жизненного цикла React из функциональных компонентов. Хуки не работают внутри классов — они дают вам возможность использовать React без классов.
(позволяет использовать состояние и другие возможности React без написания классов)
!Хук useState – с самого простого и важного хука – useState. Из самого названия становится понятно, что он связан с состоянием компонента. Именно благодаря ему у функциональных компонентов появилось состояние.
!Хук useContext – Чтобы передать какие-то данные в компонент есть способ – context. контекст позволяет передавать данные от родительского компонента к дочернему, минуя промежуточные.
!Хуки useEffect и useLayoutEffect – методы жизненного цикла служат для того, чтобы совершать какие-то операции на разных стадиях жизни компонента. Для этого у нас есть два хука – useEffect и useLayoutEffect. Они похожи между собой, за исключением небольшой разницы в рендеринге. В случае с useLayoutEffect React не запускает рендеринг построенного DOM дерева до тех пор, пока не отработает useLayoutEffect. Если же мы берём useEffect, то React сразу запускает рендеринг построенного DOM, не дожидаясь запуска useEffect.
!Хук useRef – прямая связь с узлами, когда необходимо обратиться к какому-то DOM-объекту напрямую.
!Хук useReducer – как аналог Redux в составе React. Этот хук позволяет вынести данные из компонентов.
!Хук useMemo – Этот хук позволяет не производить одни и те же вычисления много раз. 
!Хук useCallback – это функция, при каждом рендеринге запускается всё, что объявлено в ней. 
!Пользовательские хуки – это те же самые функции, которые внутри себя используют какие-либо из стандартных хуков. Единственное требование, которое здесь необходимо соблюдать – относиться к ним, как к хукам. То есть, соблюдать правила, что мы используем при работе с хуками: не вызывать их внутри условных конструкций (таких, как if или switch) и внутри циклов (например for), а также не использовать хуки внутри колбэков других хуков. 
\-\-\-\-\-\-\-\-\
Рендеринг компонентов
!Рендеринг — это процесс, в рамках которого React опрашивает ваши компоненты, требуя от них актуальное описание той секции пользовательского интерфейса, за которую они отвечают, основываясь на текущей комбинации пропсов (props) и состояния (state).
React начинает процесс рендеринга с корня дерева компонентов и циклически спускается вниз, чтобы найти все компоненты, помеченные как требующие обновления. Для каждого помеченного компонента React вызывает либо classComponentInstance.render() (для классовых компонентов), либо FunctionComponent() (для функциональных компонентов) и сохраняет результат рендеринга.
Результат рендеринга компонентов обычно представлен в виде JSX-кода, который затем компилируется и развертывается как JS-код, принимая вид серии вызовов React.createElement(). Функция createElement возвращает React-элементы, представляющие собой простые JS-объекты, описывающие желаемую структуру пользовательского интерфейса.
\-\-\-\-\-\-\-\-\
Компоненты высшего порядка
!Компонент высшего порядка — это функция, которая принимает компонент и возвращает новый компонент.
Компонент высшего порядка (HOC)-это продвинутая техника React для повторного использования логики компонентов. HOC сами по себе не являются частью API React. Это паттерн, который возникает из композиционной природы React. Конкретно, компонент более высокого порядка - это функция, которая принимает компонент и возвращает новый компонент.
Если обычный компонент преобразует пропсы в UI, то компонент высшего порядка преобразует компонент в другой компонент.
\-\-\-\-\-\-\-\-\
Оптимизация 
!Методы оптимизации производительности React
1. Сохранение состояния компонента там, где это необходимо, 
чтобы повторная отрисовка компонента происходила только тогда, когда это необходимо, мы можем извлечь часть кода, которая заботится о состоянии компонента, сделав ее локальной.
2. Компоненты Memoizing React для предотвращения ненужных повторных рендеров
Мемоизация — это стратегия оптимизации, которая кэширует операцию визуализации компонента, сохраняет результат в памяти и возвращает кэшированный результат для тех же входных данных.
3. Разделение кода в React с помощью динамического импорта
Благодаря разделению кода React позволяет нам разделить большой файл на несколько фрагментов с помощью динамического импорта с последующей ленивой загрузкой этих фрагментов по запросу с помощью React.lazy. Эта стратегия значительно улучшает производительность страницы сложного приложения React.
4. Виртуализация окон или списков в React
По концепции работы с окнами мы можем отображать в DOM только видимую для пользователя часть. Затем при прокрутке отображаются оставшиеся элементы списка, заменяя элементы, выходящие из области просмотра. Этот метод может значительно улучшить производительность рендеринга большого списка. И react-window, и react-virtualized — две популярные библиотеки, которые могут реализовать такую концепцию.
5. Ленивая загрузка изображений в React
Чтобы оптимизировать приложение, состоящее из нескольких изображений, мы можем избежать рендеринга всех изображений одновременно, чтобы сократить время загрузки страницы. При отложенной загрузке мы можем подождать, пока каждое из изображений не появится в окне просмотра, прежде чем визуализировать их в DOM.

\-\-\-\-\-\-\-\-\
Библиотеки, используемые вместе с React
1. React Query
Известно, что React Query, недостающая библиотека управления состоянием для React.
В документации к ней говорится: «Получайте, кэшируйте и обновляйте данные в ваших приложениях React, не затрагивая никакого "глобального состояния"».
Преимущества
    Автоматическое кэширование
    Автоматическое обновление данных в фоновом режиме
    Значительно сокращает объем кода
2. React Hook Form
React Hook Form - это современная библиотека обработки форм, которая может поднять эффективность работы вашей формы на совершенно новый уровень.
Преимущества
    Уменьшает объем кода
    Сокращает ненужный ре-рендеринг.
    Легко интегрируется с современными библиотеками пользовательского интерфейса (UI)
3. React Window
React Window используется для рендеринга длинных списков. Данный код рендерит только то, что вы видите на экране.
4. React LazyLoad
Ленивая загрузка - это техника, используемая для загрузки только того, что вам нужно. Таким образом, она повышает производительность, не расходуя без необходимости вычислительные мощности.
Преимущества
    Повышенная производительность
    Поддерживает рендеринг на стороне сервера
5. Почему вы выполняете рендеринг (Why Did You Render)
Why Did You Render, помогает нам найти проблемы с производительностью и решить их. Вы просто включаете его в любом компоненте, и он сообщает вам, почему именно происходит рендеринг.
6. Reselect
редьюсеры Redux могут хранить большое количество данных, и если вы передадите всё хранилище в какой-либо компонент, это приведет к тому, что он будет заново рендериться каждый раз, когда что-либо в этом хранилище будет обновляться.
Reselect решает эту проблему, меморизуя значения и передавая только то, что необходимо.
Преимущества
    Селекторы могут вычислять производные данные, что позволяет Redux хранить минимально возможное состояние.
    Селекторы эффективны. Селектор не пересчитывается, если один из его аргументов не изменился.
    Селекторы являются составными. Они могут быть использованы в качестве входных данных для других селекторов.
7. Deep Equal
это известная библиотека, которую можно использовать для сравнения. Это очень удобно. Ведь в JavaScript, несмотря на то, что два объекта могут иметь одинаковые значения, они считаются разными, поскольку указывают на разные области памяти.

!!!!!!!!
DOM (Document Object Model).
Объектная Модель Документа (DOM) – это программный интерфейс (API) для HTML и XML документов. DOM предоставляет структурированное представление документа и определяет то, как эта структура может быть доступна из программ, которые могут изменять содержимое, стиль и структуру документа. Представление DOM состоит из структурированной группы узлов и объектов, которые имеют свойства и методы.

WEB API, БРАУЗЕРЫ:

!Web API или Web Service API –это интерфейс обработки приложений между веб-сервером и веб-браузером. Все веб-сервисы являются API, но не все API являются веб-сервисами. REST API – это особый тип Web API, в котором используется стандартный архитектурный стиль.
\-\-\-\-\-\-\-\-\
Принципы работы браузера
Браузер — это клиентская программа, позволяющая в простой форме посылать запросы серверам на загрузку веб-страниц. В задачи браузера помимо простейших операций по связи с серверами входит: обработка полученной HTML-разметки, интерпретация стилей и скриптов, контроль ошибок и по возможности их исправление, хранение пользовательской информации. Браузеры, представленные различными компаниями, могут по-разному реализовывать эти механизмы или игнорировать какие-либо из них. Такие возможности, объединенные в виде программы, называется браузерным движком. 
Этапы рабочего процесса браузера:
    При вводе имени сайта в адресной строке, клике по ссылке в поисковой системе или на любом сайте, браузер посылает запрос серверу на загрузку определенной страницы
    Сервер получает запрос и проверяет, есть ли такая страница
    Сервер осуществляет передачу HTML-разметки страницы браузеру
    Браузер обрабатывает разметку и выводит результат пользователю
    Механизм рендеринга
!Навигация - это первый этап при загрузке приложения. Он происходит каждый раз, когда пользователь запрашивает страницу, вводя URL в адресную строку браузера, нажимает на ссылку, отправляет заполненные поля формы и выполняет некоторые другие действия.
+DNS запрос
Первый шаг навигации к странице - это поиск места, откуда нужно запрашивать данные. Если вы переходите на https://example.com, браузер грузит HTML-код страницы с IP-адреса 93.184.216.34. Если вы никогда ранее не были на этом сайте, произойдёт поиск DNS записи.
+TCP Рукопожатие (Handshake)
В тот момент, когда IP адрес становится известен, браузер начинает установку соединения к серверу с помощью рукопожатия TCP three-way handshake (en-US). Этот механизм спроектирован так, чтобы два устройства, пытающиеся установить связь, могли обменяться параметрами соединения, прежде чем приступать к передаче данных. Чаще всего - через защищённое соединение HTTPS.
+TLS Переговоры (Negotiation)
Для установки безопасных соединений с использованием HTTPS требуется ещё одно рукопожатие. На этот раз - TLS переговоры. На этом шаге определяется, какой шифр будет использоваться для шифрования соединения, удостоверяется надёжность сервера и устанавливается безопасное соединение. Этот шаг также требует несколько дополнительных сообщений, которыми должны обменяться сервер и браузер, прежде чем данные будут посланы.
!Ответ на запрос
Как только мы установили соединение с веб-сервером, браузер отправляет инициирующий HTTP GET запрос от имени пользователя. Чаще всего запрашивается HTML файл. В момент, когда сервер получает запрос, он начинает ответ с посылки заголовков ответа и содержимым HTML-файла.
+TCP медленный старт / правило 14kb
Объём первого пакета данных - всегда 14KB. Это часть спецификации TCP slow start (en-US) - алгоритма, который балансирует скорость соединения. Такое правило позволяет постепенно, по мере необходимости, увеличивать размеры передаваемых данных, пока не будет определена максимальная ширина канала.
+Контроль переполнения
Любое соединение имеет ограничения, связанные с аппаратной и сетевой системами. Если сервер отправит слишком много пакетов за раз - они могут быть отброшены. Для того, чтобы избежать таких проблем, браузер должен реагировать на получение пакетов и подтверждать, что он получает их. Такой ответ-подтверждение называется Aknowledgements (ACK).
!Парсинг
Как только браузер получает первый кусочек данных, он сразу начинает обрабатывать получаемую информацию. Эта обработка называется "Парсинг" (Parsing). Во время парсинга получаемые данные преобразуются в DOM и CSSOM (en-US), которые напрямую участвуют в отрисовке.
DOM (Объектная модель документа) - это внутреннее представление разметки HTML. Браузер предоставляет доступ к манипуляции объектами этой модели через разные JavaScript API.
+Построение дерева объектной модели документа
Первый шаг - это обработка разметки HTML и построение дерева DOM. Обработка HTML включает в себя токенизацию и построение дерева. HTML-токены состоят из тегов старта и финиша, а также атрибутов. Если документ сформирован правильно, его обработка прямолинейна и быстра. Парсер (обработчик) преобразует входящие токены в документ и строит дерево документа.
Объектная модель документа (DOM) описывает содержимое документа. Элемент <html> - это первый тег и корневой элемент дерева документа. Дерево отражает связи и иерархию между разными тегами. Теги, вложенные в другие теги являются детьми. Чем больше существует узлов в дереве, тем сложнее это дерево построить.
+Сканер предзагрузки
Построение дерева DOM занимает весь поток процесса. Так как это явно узкое место в производительности, был создан особый сканер предзагрузки. Он обрабатывает доступное содержимое документа и запрашивает высокоприоритетные ресурсы (CSS, JavaScript и шрифты). Благодаря этому сканеру нам не нужно ждать, пока парсер дойдёт до конкретного места, где вызывается ресурс. Он запрашивает и получает эти данные заранее, в фоновом режиме, так что когда основной поток HTML-парсера доходит до запроса ресурса, высока вероятность, что ресурс уже запрошен или находится в процессе загрузки. Оптимизации, которые даёт этот сканер, уменьшают время блокирования рендера.
+Построение модели стилей CSSOM
Второй шаг при прохождении критического пути рендеринга - это обработка CSS и построение CSSOM дерева. CSSOM (объектная модель CSS) похожа на DOM. И DOM, и CSSOM - это деревья. Они являются независимыми структурами данных. Браузер преобразует CSS файлы в карту стилей, которую он может понять и с которой может работать. Браузер считывает каждый набор правил в CSS, создаёт дерево узлов с родителями, детьми и соседями, основываясь на CSS селекторах.
Как и в HTML, браузер должен преобразовать полученные правила CSS во что-то, с чем он может работать. Таким образом, весь этот процесс - это повторение формирования DOM, только для CSS.
!Остальные процессы
+Компиляция JavaScript
Как CSS обработан и CSSOM создан, другие ресурсы, например, JavaScript-файлы, продолжают загружаться (спасибо сканеру предзагрузки). JavaScript по окончании загрузки должен быть интерпретирован, скомпилирован, обработан и исполнен. Скрипты преобразовываются в абстрактное синтаксическое дерево (AST). Некоторые браузеры берут Abstract Syntax Tree и передают его в интерпретатор, который преобразует дерево в байт-код. Байт-код исполняется в основном потоке. Весь этот процесс называется компиляцией.
+Построение дерева доступности
Браузер также строит дерево доступности, которое используется устройствами-помощниками для понимания и интерпретирования контента. Объектная модель доступности (accessibility object model, AOM) - это семантическая версия DOM. Браузер обновляет AOM в тот же момент, когда обновляется DOM. В то же время, дерево доступности не может быть изменено вспомогательными технологиями.
!Рендеринг
Этапы рендеринга включают в себя стилизацию, компоновку (layout), отрисовку (paint) и, в некоторых случаях, композицию (composition). CSSOM и DOM деревья, созданные на предыдущем этапе комбинируются в дерево рендера, которое затем используется для расчёта положения каждого видимого элемента. После этого элементы будут отрисованы на экране. В некоторых случаях содержимое может быть вынесено на отдельные слои и совмещено (composition) - такой подход увеличивает производительность, позволяя отрисовывать содержимое экрана на графическом процессоре вместо ЦПУ. Это освобождает основной поток.
+Стилизация
Третий шаг в критическом пути рендеринга - это комбинирование DOM и CSSOM в дерево рендеринга. Конструирование этого дерева начинается с прохода всего DOM-дерева от корня, с выявлением каждого видимого узла.
Элементы, которые не должны быть показаны, например, <head>, а так же их дети или любые элементы с display:none, такие как script { display: none; }, не будут включены в дерево рендера, так как они не должны быть отрисованы. Узлы с правилом visibility: hidden включены в дерево рендера, так как они всё равно занимают своё место. Так как мы не указали никаких специальных правил для перезаписи стилей агента по умолчанию, узел script в примере выше также не будет включён в дерево рендера.
+Компоновка (Layout)
Четвёртый шаг на критическом пути рендеринга - это запуск компоновки (layout) элементов дерева рендера. На этом шаге вычисляется геометрия каждого узла, то есть ширина, высота, положение элементов. Reflow (перекомпоновка) - это любой последующий процесс определения размеров и позиции для любой из частей целого документа.
Как только дерево рендера построено - начинается layout. Дерево несёт в себе информацию о том, какие узлы должны быть отрисованы (даже если они невидимы), и какие стили должны быть применены, но в дереве нет никакой информации о размерах и позиции элементов. Чтобы определить эти значения, браузер начинает обход дерева.
+Отрисовка (Paint)
Последний шаг критического пути рендеринга - это отрисовка каждого отдельного узла на экране. Момент, когда это происходит впервые, называется first meaningful paint (первая значащая отрисовка). Во время фазы отрисовки или растеризации, браузер конвертирует каждый контейнер box в настоящие пиксели на экране (напомним, что данные контейнеров формируются на этапе layout). Отрисовка подразумевает рисование каждой визуальной частицы элемента на экране (текст, цвета, границы, тени) и рисование заменяемых элементов (картинки, кнопки). Браузер должен выполнять это быстро.
+Композиция (Compositing)
Когда разделы документа отрисованы на разных слоях, а один слой находится над другим или перекрывает его, становится необходима композиция. Этот шаг позволяет браузеру гарантировать, что каждый слой отрисован на экране в правильном порядке, а содержимое отображается корректно.
!Интерактивность
Можно было бы подумать, что как только основной поток завершает отрисовку страницы - "всё готово". Это не всегда так. Если среди загружаемых ресурсов есть JavaScript, загрузка которого была корректно отложена, а запуск которого происходит только после события onload, основной поток начинает обработку скриптов. Во время этой обработки браузер не может обрабатывать события прокрутки, нажатий и др.
Time to Interactive (TTI, время до интерактивности) - это показатель того, как много времени проходит между самым первым сетевым запросом и моментом, когда страница становится интерактивной. В хронологии этот этап следует сразу за First Contentful Paint. Интерактивностью называется показатель того, что страница отреагировала на действие пользователя за время в 50мс. Если процессор занят обработкой, компиляцией и выполнением JavaScript, то браузер не может отреагировать достаточно быстро, а значит страница считается не интерактивной.
\-\-\-\-\-\-\-\-\
HTTP, 
!HTTP — это протокол, позволяющий получать различные ресурсы, например HTML-документы. Протокол HTTP лежит в основе обмена данными в Интернете. HTTP является протоколом клиент-серверного взаимодействия, что означает инициирование запросов к серверу самим получателем, обычно веб-браузером (web-browser). Полученный итоговый документ будет (может) состоять из различных поддокументов, являющихся частью итогового документа: например, из отдельно полученного текста, описания структуры документа, изображений, видео-файлов, скриптов и многого другого.
!HTTP поток
Когда клиент хочет взаимодействовать с сервером, являющимся конечным сервером или промежуточным прокси, он выполняет следующие шаги:
    Открытие TCP соединения: TCP-соединение будет использоваться для отправки запроса (или запросов) и получения ответа. Клиент может открыть новое соединение, переиспользовать существующее или открыть несколько TCP-соединений к серверу.
    Отправка HTTP-сообщения: HTTP-сообщения (до HTTP/2) являются человекочитаемыми. Начиная с HTTP/2, простые сообщения инкапсулируются во фреймы, делая невозможным их чтение напрямую, но принципиально остаются такими же.
    GET / HTTP/1.1
    Host: developer.mozilla.org
    Accept-Language: fr
Читает ответ от сервера:
HTTP/1.1 200 OK
Date: Sat, 09 Oct 2010 14:28:02 GMT
Server: Apache
Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT
ETag: "51142bc1-7449-479b075b2891b"
Accept-Ranges: bytes
Content-Length: 29769
Content-Type: text/html

<!DOCTYPE html... (here comes the 29769 bytes of the requested web page)
    Закрывает или переиспользует соединение для дальнейших запросов.
Если активирован HTTP-конвейер, несколько запросов могут быть отправлены без ожидания получения первого ответа целиком. HTTP-конвейер тяжело внедряется в существующие сети, где старые куски ПО сосуществуют с современными версиями. HTTP-конвейер был заменён в HTTP/2 на более надёжные мультиплексные запросы во фрейме.
\-\-\-\-\-\-\-\-\
CORS
Cross-origin resource sharing (CORS; с англ. — «совместное использование ресурсов между разными источниками») — технология современных браузеров, которая позволяет предоставить веб-страницам доступ к ресурсам другого домена. 
!Суть технологии CORS
Есть три домена, позволяющие загрузить ресурсы с сервера U. Для того, чтобы это стало возможным, веб-серверу U, который отдает контент, достаточно указать в заголовке ответа Access-Control-Allow-Origin список доверенных доменов: A, B, C. Тогда для страниц этих доменов не будут действовать ограничения принципа одинакового источника на запрашиваемые страницы:
Access-Control-Allow-Origin: A, B, C

После этого, страницы доменов A, B, C смогут загружать контент с сервера U.
Для PHP это реализуется вызовом функции header():

<?php
    header("Access-Control-Allow-Origin: http://example.com");
?>

!Пример использования
Для инициализации cross-origin запроса браузер клиента добавляет в HTTP-запрос указание Origin (домена сайта, с которого происходит запрос). Например, страница http://www.a.com/page.html пытается получить данные со страницы http://www.b.com/cors.txt. В случае если браузер клиента поддерживает технологию CORS, запрос будет выглядеть так:

GET /cors.txt HTTP/1.1
Host: www.b.com
Origin: www.a.com

Если сервер www.b.com разрешает получение данных с www.a.com, то в ответе сервера будет присутствовать строка:

Access-Control-Allow-Origin: http://www.a.com

Если в ответе сервера отсутствует данная строка, то браузер, поддерживающий технологию CORS, вернёт код ошибки вместо данных.
В случае, если сервер хочет разрешить доступ для страниц с любого домена, он может указать в ответе:

Access-Control-Allow-Origin: *

Если сервер хочет разрешить доступ более чем одному домену, то в ответе сервера должно быть по одной строчке Access-Control-Allow-Origin для каждого домена.

Access-Control-Allow-Origin: http://www.a.com
Access-Control-Allow-Origin: http://www.b.com
Access-Control-Allow-Origin: http://www.c.com

На практике чаще используется запись из нескольких доменов, разделенных пробелом[1]:
 Access-Control-Allow-Origin: http://www.a.com http://www.b.com http://www.c.com

!!!!!!!!
ПРОЧЕЕ:
\-\-\-\-\-\-\-\-\
Тестирование
!Типы тестов
+Модульные, или юнит-тесты
Работают с отдельными блоками (модулями) кода, например, функциями или классами. Они проверяют, что при определенных входных данных результат работы соответствует ожидаемому
+Интеграционные тесты
Иногда модули по отдельности работают корректно, но их взаимодействие происходит не так, как ожидалось. Интеграционные тесты работают с целыми процессами, проверяя правильность взаимодействия отдельных модулей и побочные эффекты. 
+Сквозные, или end-to-end тесты
E2E-тесты работают по принципу черного ящика, игнорируя внутреннюю структуру приложения. Их задача протестировать функционирование сценариев в целом, глазами пользователя.
!Запуск тестов
+Способ #1
Тесты подключаются как JS-скрипты на html-страницу и выполняются прямо в браузере.
+Способ #2
Запуск в headless-браузере, без реального рендеринга на экране. Удобно и быстро, можно запускать даже из командной строки.
+Способ #3
Запуск в Node.js. В этом случае придется имитировать DOM-структуру страницы с помощью специальных инструментов, например, библиотеки jsdom. 
!Задачи тестирования
Тестирование – это огромная сфера разработки, которая включает в себя множество задач. Различные инструменты могут решать лишь одну из них или же сразу несколько. Чаще всего для тестирования разработчик использует комбинацию таких инструментов.
+Запуск тестов
Создание среды для запуска тестов (в браузере или Node.js) и ее настройка. Инструменты этой группы позволяют указать набор браузеров для тестирования, плагины, которые нужно использовать, способ форматирования результатов и т. д.
+Структура тестов
Организация отдельных тестов в группы для удобства чтения и простого масштабирования.
+Функции утверждения
Различные способы проверить, возвращает ли тест именно то значение, которое вы ожидаете.
+Вывод результатов
Удобный вывод результатов тестирования с указанием на ошибки.
Инструменты: Mocha, Jasmine, Jest, Karma, TestCafe, Cypress
+Изоляция части кода
Очень часто тестируемая часть кода крепко связана с другими процессами, и ее необходимо выделить и изолировать. Для этого используются различные фейковые элементы – моки (mocks) и стабы (stubs, заглушки), которые имитируют нужную структуру или поведение.
Кроме этого существуют еще шпионы (spies), которые присоединяются к реальному коду и контролируют его работу. Они могут считать количество вызовов функции или запоминать ее входные параметры. 
+Снепшоты (snapshots)
Моментальные снимки модулей, которые можно сравнивать между собой для обнаружения изменений между разными версиями.
+Покрытие кода
Создание отчетов о том, какая часть кода покрыта тестами.
+Контроллеры браузера
Имитация действий пользователя в браузере для проведения функциональных тестов.
+Визуальная регрессия
Сравнение изображения веб-страницы с изображениями предыдущих версий.
!Полезные инструменты
+jsdom
Эта библиотека имитирует браузерную среду (с DOM и HTML) исключительно методами JS.
Позволяет выполнять тесты намного быстрее, но покрывает не все возможности реальных браузеров.
Впрочем, сообщество активно совершенствует jsdom, и для большинства задач тестирования вам ее точно хватит.
+Storybook
Storybook – это не инструмент тестирования как такового, однако он стимулирует создавать изолированные компоненты, которые легко тестировать. А с помощью Chromatic, о которой мы еще поговорим, вы фактически можете протестировать компоненты из своей storybook.
+Testing Library
Простые и очень удобные утилиты для тестирования на различных платформах (React, Preact, React Native, Angular, Vue, Svelte и Marko). Хорошо интегрируются с другими инструментами тестирования, например, Cypress, Puppeteer, Testcafe и Nightwatch.
+Electron
Платформа Electron позволяет писать кросс-платформенные десктопные приложения на JS + HTML + CSS. У него также есть headless-режим. Ряд инструментов, например, Cypress.io, используют Electron для запуска тестов с максимальными контролем браузера.
+Istanbul
Формирует отчеты о покрытии кода модульными тестами для каждого оператора, строчки, функции и т.д.
+Karma
Создает тестовый сервер для запуска тестов на веб-странице, которую можно запустить в большинстве браузеров, в том числе в headless-режиме, а также в браузерных средах вроде jsdom.
+Chai
Самая популярная библиотека утверждений с большим количеством расширений.
+Unexpected
Еще одна библиотека утверждения с немного другим синтаксисом и возможностью расширения. На его базе создана библиотека unexpected-react, для тестирования React-приложений.
+Sinon.JS
Предоставляет большой набор мощных шпионов, моков и стабов для любого фреймворка модульного тестирования JavaScript-кода.
+testdouble.js
Менее популярный аналог Sinon.
+Wallaby
Платный инструмент для запуска тестов прямо в IDE (поддерживает все популярные среды) в режиме реального времени.
+Cucumber
Этот фреймворк реализует BDD-подход и позволяет писать человекопонятные тесты на различных языках.
!Фреймворки для модульного и интеграционного тестирования
+Jest +jasmine +mocha +AVA
!Behavior Driven Development (BDD)
Давайте начнём с техники под названием Behavior Driven Development или, коротко, BDD.
BDD – это три в одном: и тесты, и документация, и примеры использования.
В BDD сначала пишут спецификацию, а потом реализацию. В конце у нас есть и то, и другое.
Спецификацию можно использовать тремя способами:
    Как Тесты – они гарантируют, что функция работает правильно.
    Как Документацию – заголовки блоков describe и it описывают поведение функции.
    Как Примеры – тесты, по сути, являются готовыми примерами использования функции.
Имея спецификацию, мы можем улучшить, изменить и даже переписать функцию с нуля, и при этом мы будем уверены, что она продолжает работать правильно.
Это особенно важно в больших проектах, когда одна функция может быть использована во множестве мест. Когда мы вносим в такую функцию изменения, у нас нет никакой возможности вручную проверить, что она продолжает работать правильно во всех местах, где её используют.
Не имея тестов, людям приходится выбирать один из двух путей:
    Внести изменения, и неважно, что будет. Потом у наших пользователей станут проявляться ошибки, ведь мы наверняка что-то забудем проверить вручную.
    Или же, если наказание за ошибки в коде серьёзное, то люди просто побоятся вносить изменения в такие функции. Код будет стареть, «зарастать паутиной», и никто не захочет в него лезть. Это нехорошо для разработки.
Автоматическое тестирование кода позволяет избежать этих проблем!
Если проект покрыт тестами, то вышеупомянутые проблемы не возникают. После любых изменений мы можем запустить тесты и увидеть результаты огромного количества проверок, сделанных за секунды.
Кроме того, код, хорошо покрытый тестами, как правило, имеет лучшую архитектуру.
Это естественно, ведь такой код легче менять и улучшать. Но не только по этой причине.
Для написания тестов нужно организовать код таким образом, чтобы у каждой функции была ясно поставленная задача и точно определены её аргументы и возвращаемое значение. А это означает, что мы получаем хорошую архитектуру с самого начала.
В реальности это не всегда так просто. Иногда сложно написать спецификацию до того, как будет написана реализация, потому что не всегда чётко понятно, как та или иная функция должна себя вести. Но в общем и целом написание тестов делает разработку быстрее, а итоговый продукт более стабильным.
\-\-\-\-\-\-\-\-\ 
Отладка
!Отладка – это процесс поиска и исправления ошибок в скрипте. Все современные браузеры и большинство других сред разработки поддерживают инструменты для отладки – специальный графический интерфейс, который сильно упрощает отладку. Он также позволяет по шагам отследить, что именно происходит в нашем коде.
+Панель «Исходный код» («Sources»)
использовать браузер Chrome, так как у него достаточно возможностей, в большинстве других браузеров процесс будет схожим.
+Консоль
При нажатии на клавишу Esc в нижней части экрана вызывается консоль, где можно вводить команды и выполнять их клавишей Enter.
Результат выполнения инструкций сразу же отображается в консоли.
+Точки останова (breakpoints)
Давайте разберёмся, как работает код нашей тестовой страницы. В файле hello.js щёлкните на номере строки 4. Да-да, щёлкайте именно по самой цифре, не по коду.
Ура! Вы поставили точку останова. А теперь щёлкните по цифре 8 на восьмой линии.
+Команда debugger
Выполнение кода можно также приостановить с помощью команды debugger прямо изнутри самого кода:
function hello(name) {
  let phrase = `Привет, ${name}!`;
  debugger;  // <-- тут отладчик остановится
  say(phrase);
}
Такая команда сработает только если открыты инструменты разработки, иначе браузер ее проигнорирует.
+Чтобы понять, что происходит в коде, щёлкните по стрелочкам справа:
    1.Watch– показывает текущие значения для любых выражений.
    Вы можете нажать на + и ввести выражение. Отладчик покажет его значение, автоматически пересчитывая его в процессе выполнения.
    2.Call Stack – показывает цепочку вложенных вызовов.
    В текущий момент отладчик находится внутри вызова hello(), вызываемого скриптом в index.html (там нет функции, поэтому она называется “анонимной”).
    Если вы нажмёте на элемент стека (например, «anonymous»), отладчик перейдёт к соответствующему коду, и нам представляется возможность его проанализировать.
    3.Scope показывает текущие переменные.
    Local показывает локальные переменные функций, а их значения подсвечены прямо в исходном коде.
    В Global перечисляются глобальные переменные (то есть вне каких-либо функций).
    Там также есть ключевое слово this, которое мы ещё не изучали, но скоро изучим.
+Пошаговое выполнение скрипта
+Логирование
Чтобы вывести что-то на консоль из нашего кода, существует функция console.log
!Итого Отладка
Приостановить выполнение скрипта можно тремя способами:
    Точками останова (breakpoints).
    Использованием в коде команд debugger.
    При ошибке (если инструменты разработчика открыты и кнопка «включена»).
При остановке мы можем отлаживать: анализировать переменные и пошагово пройти по процессу, чтобы отыскать проблему.
\-\-\-\-\-\-\-\-\
State manager’ы
!популярные инструменты для JavaScript state-management, а именно: redux и mobx.
+Redux
Это легковесная библиотека, которая весит всего 2kB и представляет единый контейнер управляемых состояний для js приложения. Основными плюсами redux являются его малый вес и гибкость. C помощью redux можно разрабатывать приложения любого размера.
+mobx
Сначала давайте определимся с основными терминами:
    1.Наблюдаемое состояние (observable state). Любое значение, которое может быть изменено и может служить источником для вычисленных значений, является состоянием. MobX может сделать большинство типов значений (примитивы, массивы, классы, объекты и т.д.) и даже (потенциально циклические) ссылки наблюдаемыми из коробки.
    2.Вычисленные значения (computed values). Любое значение, которое может быть вычислено с помощью функции, использующей исключительно другие вычисленные значения. Вычисленные значения могут варьироваться от конкатенации нескольких строк до получения сложных объектов и визуализаций. Поскольку вычисленные значения являются наблюдаемыми сами по себе, даже отображение всего пользовательского интерфейса может быть выведено из наблюдаемого состояния. Вычисленные значения могут быть рассчитаны либо лениво, либо как реакция на изменения состояния.
    3.Реакции (reactions). Реакция немного похожа на вычисленное значение, но вместо того, чтобы произвести новое значение, она дает побочный эффект. Реакции соединяют реактивное и императивное программирование для таких вещей, как вывод в консоль, выполнение сетевых запросов, инкрементальное обновление дерева компонентов React для обновления DOM и т.д.
    4.Экшны (actions). Экшны являются основным средством изменения состояния. Экшны не являются реакцией на изменения состояния, а берут источники изменений, такие как пользовательские события или входящие соединения через веб-сокеты, для изменения наблюдаемого состояния.
+Управление состоянием/state management — это механизм, позволяющий создавать реактивные переменные, фиксировать изменения их значений и уведомлять об этом "заинтересованные" компоненты.
